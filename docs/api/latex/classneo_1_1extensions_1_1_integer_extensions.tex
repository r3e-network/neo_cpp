\doxysection{neo\+::extensions\+::Integer\+Extensions Class Reference}
\hypertarget{classneo_1_1extensions_1_1_integer_extensions}{}\label{classneo_1_1extensions_1_1_integer_extensions}\index{neo::extensions::IntegerExtensions@{neo::extensions::IntegerExtensions}}


Extension methods for integers.  




{\ttfamily \#include $<$integer\+\_\+extensions.\+h$>$}

\doxysubsubsection*{Static Public Member Functions}
\begin{DoxyCompactItemize}
\item 
static uint8\+\_\+t \mbox{\hyperlink{classneo_1_1extensions_1_1_integer_extensions_aefdb24d869b72931073a4264c64452fa}{Get\+Var\+Size}} (int32\+\_\+t value)
\begin{DoxyCompactList}\small\item\em Gets the size of variable-\/length of the data. \end{DoxyCompactList}\item 
static uint8\+\_\+t \mbox{\hyperlink{classneo_1_1extensions_1_1_integer_extensions_a9ada14044cedcaa4387792135ef271e5}{Get\+Var\+Size}} (uint16\+\_\+t value)
\begin{DoxyCompactList}\small\item\em Gets the size of variable-\/length of the data. \end{DoxyCompactList}\item 
static uint8\+\_\+t \mbox{\hyperlink{classneo_1_1extensions_1_1_integer_extensions_afd8533bc99bfdfcbfaed5d0fbca7c1fb}{Get\+Var\+Size}} (uint32\+\_\+t value)
\begin{DoxyCompactList}\small\item\em Gets the size of variable-\/length of the data. \end{DoxyCompactList}\item 
static uint8\+\_\+t \mbox{\hyperlink{classneo_1_1extensions_1_1_integer_extensions_abce12aa0b0a6d1400bcfd6b6a4b97b92}{Get\+Var\+Size}} (int64\+\_\+t value)
\begin{DoxyCompactList}\small\item\em Gets the size of variable-\/length of the data. \end{DoxyCompactList}\item 
static uint8\+\_\+t \mbox{\hyperlink{classneo_1_1extensions_1_1_integer_extensions_af7f1e7e507b4f34f936fad45bc652b86}{Get\+Var\+Size}} (uint64\+\_\+t value)
\begin{DoxyCompactList}\small\item\em Gets the size of variable-\/length of the data. \end{DoxyCompactList}\item 
static std\+::vector$<$ uint8\+\_\+t $>$ \mbox{\hyperlink{classneo_1_1extensions_1_1_integer_extensions_abd1da1d17d63fe12f08cfe564aa6098d}{To\+Little\+Endian\+Bytes}} (int16\+\_\+t value)
\begin{DoxyCompactList}\small\item\em Converts an integer to little-\/endian byte array. \end{DoxyCompactList}\item 
static std\+::vector$<$ uint8\+\_\+t $>$ \mbox{\hyperlink{classneo_1_1extensions_1_1_integer_extensions_ad1cf2228150333ba4cb46687bb742387}{To\+Little\+Endian\+Bytes}} (uint16\+\_\+t value)
\begin{DoxyCompactList}\small\item\em Converts an integer to little-\/endian byte array. \end{DoxyCompactList}\item 
static std\+::vector$<$ uint8\+\_\+t $>$ \mbox{\hyperlink{classneo_1_1extensions_1_1_integer_extensions_a35d0a861ac29a578805807e176086315}{To\+Little\+Endian\+Bytes}} (int32\+\_\+t value)
\begin{DoxyCompactList}\small\item\em Converts an integer to little-\/endian byte array. \end{DoxyCompactList}\item 
static std\+::vector$<$ uint8\+\_\+t $>$ \mbox{\hyperlink{classneo_1_1extensions_1_1_integer_extensions_aa559835807a6e3e24ff7d7df70370e6f}{To\+Little\+Endian\+Bytes}} (uint32\+\_\+t value)
\begin{DoxyCompactList}\small\item\em Converts an integer to little-\/endian byte array. \end{DoxyCompactList}\item 
static std\+::vector$<$ uint8\+\_\+t $>$ \mbox{\hyperlink{classneo_1_1extensions_1_1_integer_extensions_a74e3c12a84db8469a2eb84eb20f697cb}{To\+Little\+Endian\+Bytes}} (int64\+\_\+t value)
\begin{DoxyCompactList}\small\item\em Converts an integer to little-\/endian byte array. \end{DoxyCompactList}\item 
static std\+::vector$<$ uint8\+\_\+t $>$ \mbox{\hyperlink{classneo_1_1extensions_1_1_integer_extensions_a663316f09ef3ab55cc6efdabbde702f7}{To\+Little\+Endian\+Bytes}} (uint64\+\_\+t value)
\begin{DoxyCompactList}\small\item\em Converts an integer to little-\/endian byte array. \end{DoxyCompactList}\item 
static int16\+\_\+t \mbox{\hyperlink{classneo_1_1extensions_1_1_integer_extensions_a0782a975d73d99540d5e5a65026cff0e}{From\+Little\+Endian\+Bytes16}} (const std\+::vector$<$ uint8\+\_\+t $>$ \&bytes, size\+\_\+t offset=0)
\begin{DoxyCompactList}\small\item\em Converts a little-\/endian byte array to int16. \end{DoxyCompactList}\item 
static uint16\+\_\+t \mbox{\hyperlink{classneo_1_1extensions_1_1_integer_extensions_af3f652beafdabf2c2707c0cefb2c00f0}{From\+Little\+Endian\+Bytes\+U16}} (const std\+::vector$<$ uint8\+\_\+t $>$ \&bytes, size\+\_\+t offset=0)
\begin{DoxyCompactList}\small\item\em Converts a little-\/endian byte array to uint16. \end{DoxyCompactList}\item 
static int32\+\_\+t \mbox{\hyperlink{classneo_1_1extensions_1_1_integer_extensions_a4a21e62d220531def3bf5e1ce26469d6}{From\+Little\+Endian\+Bytes32}} (const std\+::vector$<$ uint8\+\_\+t $>$ \&bytes, size\+\_\+t offset=0)
\begin{DoxyCompactList}\small\item\em Converts a little-\/endian byte array to int32. \end{DoxyCompactList}\item 
static uint32\+\_\+t \mbox{\hyperlink{classneo_1_1extensions_1_1_integer_extensions_ac6ae3df7e0d0e8f30d1fa2b4bac2f420}{From\+Little\+Endian\+Bytes\+U32}} (const std\+::vector$<$ uint8\+\_\+t $>$ \&bytes, size\+\_\+t offset=0)
\begin{DoxyCompactList}\small\item\em Converts a little-\/endian byte array to uint32. \end{DoxyCompactList}\item 
static int64\+\_\+t \mbox{\hyperlink{classneo_1_1extensions_1_1_integer_extensions_a674859453aa6b9d1c532e480b48b83d5}{From\+Little\+Endian\+Bytes64}} (const std\+::vector$<$ uint8\+\_\+t $>$ \&bytes, size\+\_\+t offset=0)
\begin{DoxyCompactList}\small\item\em Converts a little-\/endian byte array to int64. \end{DoxyCompactList}\item 
static uint64\+\_\+t \mbox{\hyperlink{classneo_1_1extensions_1_1_integer_extensions_a631b997a0497f3c01c6c3139194562a2}{From\+Little\+Endian\+Bytes\+U64}} (const std\+::vector$<$ uint8\+\_\+t $>$ \&bytes, size\+\_\+t offset=0)
\begin{DoxyCompactList}\small\item\em Converts a little-\/endian byte array to uint64. \end{DoxyCompactList}\item 
static bool \mbox{\hyperlink{classneo_1_1extensions_1_1_integer_extensions_ae98e95c4eddf1579045da29c6cd88cd8}{Is\+Little\+Endian}} ()
\begin{DoxyCompactList}\small\item\em Checks if the system is little-\/endian. \end{DoxyCompactList}\end{DoxyCompactItemize}
\doxysubsubsection*{Static Private Member Functions}
\begin{DoxyCompactItemize}
\item 
{\footnotesize template$<$typename T$>$ }\\static std\+::vector$<$ uint8\+\_\+t $>$ \mbox{\hyperlink{classneo_1_1extensions_1_1_integer_extensions_a282627a5efcdd111e5489a14e958f1bb}{To\+Little\+Endian\+Bytes\+Impl}} (T value)
\begin{DoxyCompactList}\small\item\em Template function to convert integer to little-\/endian bytes. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename T$>$ }\\static T \mbox{\hyperlink{classneo_1_1extensions_1_1_integer_extensions_af32cbec2a7f6dc49aa55f229bdaeb928}{From\+Little\+Endian\+Bytes\+Impl}} (const std\+::vector$<$ uint8\+\_\+t $>$ \&bytes, size\+\_\+t offset)
\begin{DoxyCompactList}\small\item\em Template function to convert little-\/endian bytes to integer. \end{DoxyCompactList}\end{DoxyCompactItemize}


\doxysubsection{Detailed Description}
Extension methods for integers. 

\label{doc-func-members}
\Hypertarget{classneo_1_1extensions_1_1_integer_extensions_doc-func-members}
\doxysubsection{Member Function Documentation}
\Hypertarget{classneo_1_1extensions_1_1_integer_extensions_a0782a975d73d99540d5e5a65026cff0e}\index{neo::extensions::IntegerExtensions@{neo::extensions::IntegerExtensions}!FromLittleEndianBytes16@{FromLittleEndianBytes16}}
\index{FromLittleEndianBytes16@{FromLittleEndianBytes16}!neo::extensions::IntegerExtensions@{neo::extensions::IntegerExtensions}}
\doxysubsubsection{\texorpdfstring{FromLittleEndianBytes16()}{FromLittleEndianBytes16()}}
{\footnotesize\ttfamily \label{classneo_1_1extensions_1_1_integer_extensions_a0782a975d73d99540d5e5a65026cff0e} 
int16\+\_\+t neo\+::extensions\+::\+Integer\+Extensions\+::\+From\+Little\+Endian\+Bytes16 (\begin{DoxyParamCaption}\item[{const std\+::vector$<$ uint8\+\_\+t $>$ \&}]{bytes}{, }\item[{size\+\_\+t}]{offset}{ = {\ttfamily 0}}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Converts a little-\/endian byte array to int16. 


\begin{DoxyParams}{Parameters}
{\em bytes} & The byte array. \\
\hline
{\em offset} & The offset in the array. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The converted integer. 
\end{DoxyReturn}

\begin{DoxyExceptions}{Exceptions}
{\em std\+::out\+\_\+of\+\_\+range} & if there are insufficient bytes. \\
\hline
\end{DoxyExceptions}
Here is the call graph for this function\+:
% FIG 0
\Hypertarget{classneo_1_1extensions_1_1_integer_extensions_a4a21e62d220531def3bf5e1ce26469d6}\index{neo::extensions::IntegerExtensions@{neo::extensions::IntegerExtensions}!FromLittleEndianBytes32@{FromLittleEndianBytes32}}
\index{FromLittleEndianBytes32@{FromLittleEndianBytes32}!neo::extensions::IntegerExtensions@{neo::extensions::IntegerExtensions}}
\doxysubsubsection{\texorpdfstring{FromLittleEndianBytes32()}{FromLittleEndianBytes32()}}
{\footnotesize\ttfamily \label{classneo_1_1extensions_1_1_integer_extensions_a4a21e62d220531def3bf5e1ce26469d6} 
int32\+\_\+t neo\+::extensions\+::\+Integer\+Extensions\+::\+From\+Little\+Endian\+Bytes32 (\begin{DoxyParamCaption}\item[{const std\+::vector$<$ uint8\+\_\+t $>$ \&}]{bytes}{, }\item[{size\+\_\+t}]{offset}{ = {\ttfamily 0}}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Converts a little-\/endian byte array to int32. 


\begin{DoxyParams}{Parameters}
{\em bytes} & The byte array. \\
\hline
{\em offset} & The offset in the array. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The converted integer. 
\end{DoxyReturn}

\begin{DoxyExceptions}{Exceptions}
{\em std\+::out\+\_\+of\+\_\+range} & if there are insufficient bytes. \\
\hline
\end{DoxyExceptions}
Here is the call graph for this function\+:
% FIG 1
\Hypertarget{classneo_1_1extensions_1_1_integer_extensions_a674859453aa6b9d1c532e480b48b83d5}\index{neo::extensions::IntegerExtensions@{neo::extensions::IntegerExtensions}!FromLittleEndianBytes64@{FromLittleEndianBytes64}}
\index{FromLittleEndianBytes64@{FromLittleEndianBytes64}!neo::extensions::IntegerExtensions@{neo::extensions::IntegerExtensions}}
\doxysubsubsection{\texorpdfstring{FromLittleEndianBytes64()}{FromLittleEndianBytes64()}}
{\footnotesize\ttfamily \label{classneo_1_1extensions_1_1_integer_extensions_a674859453aa6b9d1c532e480b48b83d5} 
int64\+\_\+t neo\+::extensions\+::\+Integer\+Extensions\+::\+From\+Little\+Endian\+Bytes64 (\begin{DoxyParamCaption}\item[{const std\+::vector$<$ uint8\+\_\+t $>$ \&}]{bytes}{, }\item[{size\+\_\+t}]{offset}{ = {\ttfamily 0}}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Converts a little-\/endian byte array to int64. 


\begin{DoxyParams}{Parameters}
{\em bytes} & The byte array. \\
\hline
{\em offset} & The offset in the array. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The converted integer. 
\end{DoxyReturn}

\begin{DoxyExceptions}{Exceptions}
{\em std\+::out\+\_\+of\+\_\+range} & if there are insufficient bytes. \\
\hline
\end{DoxyExceptions}
Here is the call graph for this function\+:
% FIG 2
\Hypertarget{classneo_1_1extensions_1_1_integer_extensions_af32cbec2a7f6dc49aa55f229bdaeb928}\index{neo::extensions::IntegerExtensions@{neo::extensions::IntegerExtensions}!FromLittleEndianBytesImpl@{FromLittleEndianBytesImpl}}
\index{FromLittleEndianBytesImpl@{FromLittleEndianBytesImpl}!neo::extensions::IntegerExtensions@{neo::extensions::IntegerExtensions}}
\doxysubsubsection{\texorpdfstring{FromLittleEndianBytesImpl()}{FromLittleEndianBytesImpl()}}
{\footnotesize\ttfamily \label{classneo_1_1extensions_1_1_integer_extensions_af32cbec2a7f6dc49aa55f229bdaeb928} 
template$<$typename T$>$ \\
template uint64\+\_\+t neo\+::extensions\+::\+Integer\+Extensions\+::\+From\+Little\+Endian\+Bytes\+Impl$<$ uint64\+\_\+t $>$ (\begin{DoxyParamCaption}\item[{const std\+::vector$<$ uint8\+\_\+t $>$ \&}]{bytes}{, }\item[{size\+\_\+t}]{offset}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}, {\ttfamily [private]}}



Template function to convert little-\/endian bytes to integer. 


\begin{DoxyTemplParams}{Template Parameters}
{\em T} & The integer type. \\
\hline
\end{DoxyTemplParams}

\begin{DoxyParams}{Parameters}
{\em bytes} & The byte array. \\
\hline
{\em offset} & The offset in the array. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The converted integer. 
\end{DoxyReturn}
Here is the call graph for this function\+:
% FIG 3
\Hypertarget{classneo_1_1extensions_1_1_integer_extensions_af3f652beafdabf2c2707c0cefb2c00f0}\index{neo::extensions::IntegerExtensions@{neo::extensions::IntegerExtensions}!FromLittleEndianBytesU16@{FromLittleEndianBytesU16}}
\index{FromLittleEndianBytesU16@{FromLittleEndianBytesU16}!neo::extensions::IntegerExtensions@{neo::extensions::IntegerExtensions}}
\doxysubsubsection{\texorpdfstring{FromLittleEndianBytesU16()}{FromLittleEndianBytesU16()}}
{\footnotesize\ttfamily \label{classneo_1_1extensions_1_1_integer_extensions_af3f652beafdabf2c2707c0cefb2c00f0} 
uint16\+\_\+t neo\+::extensions\+::\+Integer\+Extensions\+::\+From\+Little\+Endian\+Bytes\+U16 (\begin{DoxyParamCaption}\item[{const std\+::vector$<$ uint8\+\_\+t $>$ \&}]{bytes}{, }\item[{size\+\_\+t}]{offset}{ = {\ttfamily 0}}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Converts a little-\/endian byte array to uint16. 


\begin{DoxyParams}{Parameters}
{\em bytes} & The byte array. \\
\hline
{\em offset} & The offset in the array. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The converted integer. 
\end{DoxyReturn}

\begin{DoxyExceptions}{Exceptions}
{\em std\+::out\+\_\+of\+\_\+range} & if there are insufficient bytes. \\
\hline
\end{DoxyExceptions}
Here is the call graph for this function\+:
% FIG 4
\Hypertarget{classneo_1_1extensions_1_1_integer_extensions_ac6ae3df7e0d0e8f30d1fa2b4bac2f420}\index{neo::extensions::IntegerExtensions@{neo::extensions::IntegerExtensions}!FromLittleEndianBytesU32@{FromLittleEndianBytesU32}}
\index{FromLittleEndianBytesU32@{FromLittleEndianBytesU32}!neo::extensions::IntegerExtensions@{neo::extensions::IntegerExtensions}}
\doxysubsubsection{\texorpdfstring{FromLittleEndianBytesU32()}{FromLittleEndianBytesU32()}}
{\footnotesize\ttfamily \label{classneo_1_1extensions_1_1_integer_extensions_ac6ae3df7e0d0e8f30d1fa2b4bac2f420} 
uint32\+\_\+t neo\+::extensions\+::\+Integer\+Extensions\+::\+From\+Little\+Endian\+Bytes\+U32 (\begin{DoxyParamCaption}\item[{const std\+::vector$<$ uint8\+\_\+t $>$ \&}]{bytes}{, }\item[{size\+\_\+t}]{offset}{ = {\ttfamily 0}}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Converts a little-\/endian byte array to uint32. 


\begin{DoxyParams}{Parameters}
{\em bytes} & The byte array. \\
\hline
{\em offset} & The offset in the array. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The converted integer. 
\end{DoxyReturn}

\begin{DoxyExceptions}{Exceptions}
{\em std\+::out\+\_\+of\+\_\+range} & if there are insufficient bytes. \\
\hline
\end{DoxyExceptions}
Here is the call graph for this function\+:
% FIG 5
\Hypertarget{classneo_1_1extensions_1_1_integer_extensions_a631b997a0497f3c01c6c3139194562a2}\index{neo::extensions::IntegerExtensions@{neo::extensions::IntegerExtensions}!FromLittleEndianBytesU64@{FromLittleEndianBytesU64}}
\index{FromLittleEndianBytesU64@{FromLittleEndianBytesU64}!neo::extensions::IntegerExtensions@{neo::extensions::IntegerExtensions}}
\doxysubsubsection{\texorpdfstring{FromLittleEndianBytesU64()}{FromLittleEndianBytesU64()}}
{\footnotesize\ttfamily \label{classneo_1_1extensions_1_1_integer_extensions_a631b997a0497f3c01c6c3139194562a2} 
uint64\+\_\+t neo\+::extensions\+::\+Integer\+Extensions\+::\+From\+Little\+Endian\+Bytes\+U64 (\begin{DoxyParamCaption}\item[{const std\+::vector$<$ uint8\+\_\+t $>$ \&}]{bytes}{, }\item[{size\+\_\+t}]{offset}{ = {\ttfamily 0}}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Converts a little-\/endian byte array to uint64. 


\begin{DoxyParams}{Parameters}
{\em bytes} & The byte array. \\
\hline
{\em offset} & The offset in the array. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The converted integer. 
\end{DoxyReturn}

\begin{DoxyExceptions}{Exceptions}
{\em std\+::out\+\_\+of\+\_\+range} & if there are insufficient bytes. \\
\hline
\end{DoxyExceptions}
Here is the call graph for this function\+:
% FIG 6
\Hypertarget{classneo_1_1extensions_1_1_integer_extensions_aefdb24d869b72931073a4264c64452fa}\index{neo::extensions::IntegerExtensions@{neo::extensions::IntegerExtensions}!GetVarSize@{GetVarSize}}
\index{GetVarSize@{GetVarSize}!neo::extensions::IntegerExtensions@{neo::extensions::IntegerExtensions}}
\doxysubsubsection{\texorpdfstring{GetVarSize()}{GetVarSize()}\hspace{0.1cm}{\footnotesize\ttfamily [1/5]}}
{\footnotesize\ttfamily \label{classneo_1_1extensions_1_1_integer_extensions_aefdb24d869b72931073a4264c64452fa} 
uint8\+\_\+t neo\+::extensions\+::\+Integer\+Extensions\+::\+Get\+Var\+Size (\begin{DoxyParamCaption}\item[{int32\+\_\+t}]{value}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Gets the size of variable-\/length of the data. 


\begin{DoxyParams}{Parameters}
{\em value} & The length of the data. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The size of variable-\/length of the data. 
\end{DoxyReturn}
Here is the call graph for this function\+:
% FIG 7
\Hypertarget{classneo_1_1extensions_1_1_integer_extensions_abce12aa0b0a6d1400bcfd6b6a4b97b92}\index{neo::extensions::IntegerExtensions@{neo::extensions::IntegerExtensions}!GetVarSize@{GetVarSize}}
\index{GetVarSize@{GetVarSize}!neo::extensions::IntegerExtensions@{neo::extensions::IntegerExtensions}}
\doxysubsubsection{\texorpdfstring{GetVarSize()}{GetVarSize()}\hspace{0.1cm}{\footnotesize\ttfamily [2/5]}}
{\footnotesize\ttfamily \label{classneo_1_1extensions_1_1_integer_extensions_abce12aa0b0a6d1400bcfd6b6a4b97b92} 
uint8\+\_\+t neo\+::extensions\+::\+Integer\+Extensions\+::\+Get\+Var\+Size (\begin{DoxyParamCaption}\item[{int64\+\_\+t}]{value}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Gets the size of variable-\/length of the data. 


\begin{DoxyParams}{Parameters}
{\em value} & The length of the data. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The size of variable-\/length of the data. 
\end{DoxyReturn}
\Hypertarget{classneo_1_1extensions_1_1_integer_extensions_a9ada14044cedcaa4387792135ef271e5}\index{neo::extensions::IntegerExtensions@{neo::extensions::IntegerExtensions}!GetVarSize@{GetVarSize}}
\index{GetVarSize@{GetVarSize}!neo::extensions::IntegerExtensions@{neo::extensions::IntegerExtensions}}
\doxysubsubsection{\texorpdfstring{GetVarSize()}{GetVarSize()}\hspace{0.1cm}{\footnotesize\ttfamily [3/5]}}
{\footnotesize\ttfamily \label{classneo_1_1extensions_1_1_integer_extensions_a9ada14044cedcaa4387792135ef271e5} 
uint8\+\_\+t neo\+::extensions\+::\+Integer\+Extensions\+::\+Get\+Var\+Size (\begin{DoxyParamCaption}\item[{uint16\+\_\+t}]{value}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Gets the size of variable-\/length of the data. 


\begin{DoxyParams}{Parameters}
{\em value} & The length of the data. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The size of variable-\/length of the data. 
\end{DoxyReturn}
Here is the call graph for this function\+:
% FIG 8
\Hypertarget{classneo_1_1extensions_1_1_integer_extensions_afd8533bc99bfdfcbfaed5d0fbca7c1fb}\index{neo::extensions::IntegerExtensions@{neo::extensions::IntegerExtensions}!GetVarSize@{GetVarSize}}
\index{GetVarSize@{GetVarSize}!neo::extensions::IntegerExtensions@{neo::extensions::IntegerExtensions}}
\doxysubsubsection{\texorpdfstring{GetVarSize()}{GetVarSize()}\hspace{0.1cm}{\footnotesize\ttfamily [4/5]}}
{\footnotesize\ttfamily \label{classneo_1_1extensions_1_1_integer_extensions_afd8533bc99bfdfcbfaed5d0fbca7c1fb} 
uint8\+\_\+t neo\+::extensions\+::\+Integer\+Extensions\+::\+Get\+Var\+Size (\begin{DoxyParamCaption}\item[{uint32\+\_\+t}]{value}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Gets the size of variable-\/length of the data. 


\begin{DoxyParams}{Parameters}
{\em value} & The length of the data. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The size of variable-\/length of the data. 
\end{DoxyReturn}
Here is the call graph for this function\+:
% FIG 9
\Hypertarget{classneo_1_1extensions_1_1_integer_extensions_af7f1e7e507b4f34f936fad45bc652b86}\index{neo::extensions::IntegerExtensions@{neo::extensions::IntegerExtensions}!GetVarSize@{GetVarSize}}
\index{GetVarSize@{GetVarSize}!neo::extensions::IntegerExtensions@{neo::extensions::IntegerExtensions}}
\doxysubsubsection{\texorpdfstring{GetVarSize()}{GetVarSize()}\hspace{0.1cm}{\footnotesize\ttfamily [5/5]}}
{\footnotesize\ttfamily \label{classneo_1_1extensions_1_1_integer_extensions_af7f1e7e507b4f34f936fad45bc652b86} 
uint8\+\_\+t neo\+::extensions\+::\+Integer\+Extensions\+::\+Get\+Var\+Size (\begin{DoxyParamCaption}\item[{uint64\+\_\+t}]{value}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Gets the size of variable-\/length of the data. 


\begin{DoxyParams}{Parameters}
{\em value} & The length of the data. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The size of variable-\/length of the data. 
\end{DoxyReturn}
\Hypertarget{classneo_1_1extensions_1_1_integer_extensions_ae98e95c4eddf1579045da29c6cd88cd8}\index{neo::extensions::IntegerExtensions@{neo::extensions::IntegerExtensions}!IsLittleEndian@{IsLittleEndian}}
\index{IsLittleEndian@{IsLittleEndian}!neo::extensions::IntegerExtensions@{neo::extensions::IntegerExtensions}}
\doxysubsubsection{\texorpdfstring{IsLittleEndian()}{IsLittleEndian()}}
{\footnotesize\ttfamily \label{classneo_1_1extensions_1_1_integer_extensions_ae98e95c4eddf1579045da29c6cd88cd8} 
bool neo\+::extensions\+::\+Integer\+Extensions\+::\+Is\+Little\+Endian (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Checks if the system is little-\/endian. 

\begin{DoxyReturn}{Returns}
True if the system is little-\/endian, false otherwise. 
\end{DoxyReturn}
\Hypertarget{classneo_1_1extensions_1_1_integer_extensions_abd1da1d17d63fe12f08cfe564aa6098d}\index{neo::extensions::IntegerExtensions@{neo::extensions::IntegerExtensions}!ToLittleEndianBytes@{ToLittleEndianBytes}}
\index{ToLittleEndianBytes@{ToLittleEndianBytes}!neo::extensions::IntegerExtensions@{neo::extensions::IntegerExtensions}}
\doxysubsubsection{\texorpdfstring{ToLittleEndianBytes()}{ToLittleEndianBytes()}\hspace{0.1cm}{\footnotesize\ttfamily [1/6]}}
{\footnotesize\ttfamily \label{classneo_1_1extensions_1_1_integer_extensions_abd1da1d17d63fe12f08cfe564aa6098d} 
std\+::vector$<$ uint8\+\_\+t $>$ neo\+::extensions\+::\+Integer\+Extensions\+::\+To\+Little\+Endian\+Bytes (\begin{DoxyParamCaption}\item[{int16\+\_\+t}]{value}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Converts an integer to little-\/endian byte array. 


\begin{DoxyParams}{Parameters}
{\em value} & The integer value. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The byte array in little-\/endian format. 
\end{DoxyReturn}
Here is the call graph for this function\+:
% FIG 10
\Hypertarget{classneo_1_1extensions_1_1_integer_extensions_a35d0a861ac29a578805807e176086315}\index{neo::extensions::IntegerExtensions@{neo::extensions::IntegerExtensions}!ToLittleEndianBytes@{ToLittleEndianBytes}}
\index{ToLittleEndianBytes@{ToLittleEndianBytes}!neo::extensions::IntegerExtensions@{neo::extensions::IntegerExtensions}}
\doxysubsubsection{\texorpdfstring{ToLittleEndianBytes()}{ToLittleEndianBytes()}\hspace{0.1cm}{\footnotesize\ttfamily [2/6]}}
{\footnotesize\ttfamily \label{classneo_1_1extensions_1_1_integer_extensions_a35d0a861ac29a578805807e176086315} 
std\+::vector$<$ uint8\+\_\+t $>$ neo\+::extensions\+::\+Integer\+Extensions\+::\+To\+Little\+Endian\+Bytes (\begin{DoxyParamCaption}\item[{int32\+\_\+t}]{value}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Converts an integer to little-\/endian byte array. 


\begin{DoxyParams}{Parameters}
{\em value} & The integer value. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The byte array in little-\/endian format. 
\end{DoxyReturn}
Here is the call graph for this function\+:
% FIG 11
\Hypertarget{classneo_1_1extensions_1_1_integer_extensions_a74e3c12a84db8469a2eb84eb20f697cb}\index{neo::extensions::IntegerExtensions@{neo::extensions::IntegerExtensions}!ToLittleEndianBytes@{ToLittleEndianBytes}}
\index{ToLittleEndianBytes@{ToLittleEndianBytes}!neo::extensions::IntegerExtensions@{neo::extensions::IntegerExtensions}}
\doxysubsubsection{\texorpdfstring{ToLittleEndianBytes()}{ToLittleEndianBytes()}\hspace{0.1cm}{\footnotesize\ttfamily [3/6]}}
{\footnotesize\ttfamily \label{classneo_1_1extensions_1_1_integer_extensions_a74e3c12a84db8469a2eb84eb20f697cb} 
std\+::vector$<$ uint8\+\_\+t $>$ neo\+::extensions\+::\+Integer\+Extensions\+::\+To\+Little\+Endian\+Bytes (\begin{DoxyParamCaption}\item[{int64\+\_\+t}]{value}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Converts an integer to little-\/endian byte array. 


\begin{DoxyParams}{Parameters}
{\em value} & The integer value. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The byte array in little-\/endian format. 
\end{DoxyReturn}
Here is the call graph for this function\+:
% FIG 12
\Hypertarget{classneo_1_1extensions_1_1_integer_extensions_ad1cf2228150333ba4cb46687bb742387}\index{neo::extensions::IntegerExtensions@{neo::extensions::IntegerExtensions}!ToLittleEndianBytes@{ToLittleEndianBytes}}
\index{ToLittleEndianBytes@{ToLittleEndianBytes}!neo::extensions::IntegerExtensions@{neo::extensions::IntegerExtensions}}
\doxysubsubsection{\texorpdfstring{ToLittleEndianBytes()}{ToLittleEndianBytes()}\hspace{0.1cm}{\footnotesize\ttfamily [4/6]}}
{\footnotesize\ttfamily \label{classneo_1_1extensions_1_1_integer_extensions_ad1cf2228150333ba4cb46687bb742387} 
std\+::vector$<$ uint8\+\_\+t $>$ neo\+::extensions\+::\+Integer\+Extensions\+::\+To\+Little\+Endian\+Bytes (\begin{DoxyParamCaption}\item[{uint16\+\_\+t}]{value}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Converts an integer to little-\/endian byte array. 


\begin{DoxyParams}{Parameters}
{\em value} & The integer value. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The byte array in little-\/endian format. 
\end{DoxyReturn}
Here is the call graph for this function\+:
% FIG 13
\Hypertarget{classneo_1_1extensions_1_1_integer_extensions_aa559835807a6e3e24ff7d7df70370e6f}\index{neo::extensions::IntegerExtensions@{neo::extensions::IntegerExtensions}!ToLittleEndianBytes@{ToLittleEndianBytes}}
\index{ToLittleEndianBytes@{ToLittleEndianBytes}!neo::extensions::IntegerExtensions@{neo::extensions::IntegerExtensions}}
\doxysubsubsection{\texorpdfstring{ToLittleEndianBytes()}{ToLittleEndianBytes()}\hspace{0.1cm}{\footnotesize\ttfamily [5/6]}}
{\footnotesize\ttfamily \label{classneo_1_1extensions_1_1_integer_extensions_aa559835807a6e3e24ff7d7df70370e6f} 
std\+::vector$<$ uint8\+\_\+t $>$ neo\+::extensions\+::\+Integer\+Extensions\+::\+To\+Little\+Endian\+Bytes (\begin{DoxyParamCaption}\item[{uint32\+\_\+t}]{value}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Converts an integer to little-\/endian byte array. 


\begin{DoxyParams}{Parameters}
{\em value} & The integer value. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The byte array in little-\/endian format. 
\end{DoxyReturn}
Here is the call graph for this function\+:
% FIG 14
\Hypertarget{classneo_1_1extensions_1_1_integer_extensions_a663316f09ef3ab55cc6efdabbde702f7}\index{neo::extensions::IntegerExtensions@{neo::extensions::IntegerExtensions}!ToLittleEndianBytes@{ToLittleEndianBytes}}
\index{ToLittleEndianBytes@{ToLittleEndianBytes}!neo::extensions::IntegerExtensions@{neo::extensions::IntegerExtensions}}
\doxysubsubsection{\texorpdfstring{ToLittleEndianBytes()}{ToLittleEndianBytes()}\hspace{0.1cm}{\footnotesize\ttfamily [6/6]}}
{\footnotesize\ttfamily \label{classneo_1_1extensions_1_1_integer_extensions_a663316f09ef3ab55cc6efdabbde702f7} 
std\+::vector$<$ uint8\+\_\+t $>$ neo\+::extensions\+::\+Integer\+Extensions\+::\+To\+Little\+Endian\+Bytes (\begin{DoxyParamCaption}\item[{uint64\+\_\+t}]{value}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Converts an integer to little-\/endian byte array. 


\begin{DoxyParams}{Parameters}
{\em value} & The integer value. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The byte array in little-\/endian format. 
\end{DoxyReturn}
Here is the call graph for this function\+:
% FIG 15
\Hypertarget{classneo_1_1extensions_1_1_integer_extensions_a282627a5efcdd111e5489a14e958f1bb}\index{neo::extensions::IntegerExtensions@{neo::extensions::IntegerExtensions}!ToLittleEndianBytesImpl@{ToLittleEndianBytesImpl}}
\index{ToLittleEndianBytesImpl@{ToLittleEndianBytesImpl}!neo::extensions::IntegerExtensions@{neo::extensions::IntegerExtensions}}
\doxysubsubsection{\texorpdfstring{ToLittleEndianBytesImpl()}{ToLittleEndianBytesImpl()}}
{\footnotesize\ttfamily \label{classneo_1_1extensions_1_1_integer_extensions_a282627a5efcdd111e5489a14e958f1bb} 
template$<$typename T$>$ \\
template std\+::vector$<$ uint8\+\_\+t $>$ neo\+::extensions\+::\+Integer\+Extensions\+::\+To\+Little\+Endian\+Bytes\+Impl$<$ uint64\+\_\+t $>$ (\begin{DoxyParamCaption}\item[{T}]{value}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}, {\ttfamily [private]}}



Template function to convert integer to little-\/endian bytes. 


\begin{DoxyTemplParams}{Template Parameters}
{\em T} & The integer type. \\
\hline
\end{DoxyTemplParams}

\begin{DoxyParams}{Parameters}
{\em value} & The integer value. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The byte array in little-\/endian format. 
\end{DoxyReturn}
Here is the call graph for this function\+:
% FIG 16


The documentation for this class was generated from the following files\+:\begin{DoxyCompactItemize}
\item 
include/neo/extensions/\mbox{\hyperlink{integer__extensions_8h}{integer\+\_\+extensions.\+h}}\item 
src/extensions/\mbox{\hyperlink{integer__extensions_8cpp}{integer\+\_\+extensions.\+cpp}}\end{DoxyCompactItemize}
