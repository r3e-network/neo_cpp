\doxysection{neo\+::cryptography\+::mpttrie\+::Trie Class Reference}
\hypertarget{classneo_1_1cryptography_1_1mpttrie_1_1_trie}{}\label{classneo_1_1cryptography_1_1mpttrie_1_1_trie}\index{neo::cryptography::mpttrie::Trie@{neo::cryptography::mpttrie::Trie}}


Merkle Patricia \doxylink{classneo_1_1cryptography_1_1mpttrie_1_1_trie}{Trie} implementation.  




{\ttfamily \#include $<$trie.\+h$>$}

\doxysubsubsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\mbox{\hyperlink{classneo_1_1cryptography_1_1mpttrie_1_1_trie_acb94e4c561edad5a0ae85e0b4a0ecaf8}{Trie}} (std\+::shared\+\_\+ptr$<$ \mbox{\hyperlink{classneo_1_1persistence_1_1_i_store_snapshot}{persistence\+::\+IStore\+Snapshot}} $>$ store, \mbox{\hyperlink{classneo_1_1io_1_1_u_int256}{io\+::\+UInt256}} root, bool full\+\_\+state=false)
\begin{DoxyCompactList}\small\item\em Constructs a \doxylink{classneo_1_1cryptography_1_1mpttrie_1_1_trie}{Trie} with the given store and root. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{classneo_1_1cryptography_1_1mpttrie_1_1_trie_a749d143c8e78332a2567ec3599f5f171}{Set\+Root}} (const \mbox{\hyperlink{classneo_1_1io_1_1_u_int256}{io\+::\+UInt256}} \&root\+\_\+hash)
\begin{DoxyCompactList}\small\item\em Sets the root hash of the trie. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classneo_1_1io_1_1_u_int256}{io\+::\+UInt256}} \mbox{\hyperlink{classneo_1_1cryptography_1_1mpttrie_1_1_trie_ab25dc0911c19bfe1dedec52e6c41f0c5}{Get\+Root\+Hash}} () const
\begin{DoxyCompactList}\small\item\em Gets the root hash of the trie. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classneo_1_1io_1_1_byte_vector}{io\+::\+Byte\+Vector}} \mbox{\hyperlink{classneo_1_1cryptography_1_1mpttrie_1_1_trie_a4e13bf8260b5d25a1a4809b7257473d3}{Get}} (\mbox{\hyperlink{classneo_1_1io_1_1_byte_span}{io\+::\+Byte\+Span}} key) const
\begin{DoxyCompactList}\small\item\em Gets a value by key. \end{DoxyCompactList}\item 
bool \mbox{\hyperlink{classneo_1_1cryptography_1_1mpttrie_1_1_trie_a8486a17f0dd0453858856db794889e62}{Try\+Get}} (\mbox{\hyperlink{classneo_1_1io_1_1_byte_span}{io\+::\+Byte\+Span}} key, \mbox{\hyperlink{classneo_1_1io_1_1_byte_vector}{io\+::\+Byte\+Vector}} \&value) const
\begin{DoxyCompactList}\small\item\em Tries to get a value by key. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{classneo_1_1cryptography_1_1mpttrie_1_1_trie_a617016f6ce278a2b13ac57615c35bb89}{Put}} (\mbox{\hyperlink{classneo_1_1io_1_1_byte_span}{io\+::\+Byte\+Span}} key, \mbox{\hyperlink{classneo_1_1io_1_1_byte_span}{io\+::\+Byte\+Span}} value)
\begin{DoxyCompactList}\small\item\em Puts a key-\/value pair. \end{DoxyCompactList}\item 
bool \mbox{\hyperlink{classneo_1_1cryptography_1_1mpttrie_1_1_trie_a9df71d4f2796eb7272041c5e69fd3698}{Delete}} (\mbox{\hyperlink{classneo_1_1io_1_1_byte_span}{io\+::\+Byte\+Span}} key)
\begin{DoxyCompactList}\small\item\em Deletes a key. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{classneo_1_1cryptography_1_1mpttrie_1_1_trie_a1f8e5fd88871945bbb5753cf901582f0}{Commit}} ()
\begin{DoxyCompactList}\small\item\em Commits all pending changes to the store. \end{DoxyCompactList}\item 
std\+::vector$<$ \mbox{\hyperlink{classneo_1_1io_1_1_byte_vector}{io\+::\+Byte\+Vector}} $>$ \mbox{\hyperlink{classneo_1_1cryptography_1_1mpttrie_1_1_trie_ab43f588d0c9b5c284b386b1261eb2327}{Get\+Proof}} (\mbox{\hyperlink{classneo_1_1io_1_1_byte_span}{io\+::\+Byte\+Span}} key) const
\begin{DoxyCompactList}\small\item\em Generates a Merkle proof for the given key. \end{DoxyCompactList}\end{DoxyCompactItemize}
\doxysubsubsection*{Private Member Functions}
\begin{DoxyCompactItemize}
\item 
bool \mbox{\hyperlink{classneo_1_1cryptography_1_1mpttrie_1_1_trie_aa02584df98e54895ad67fb874b27fcc2}{Try\+Get\+Internal}} (\mbox{\hyperlink{classneo_1_1cryptography_1_1mpttrie_1_1_node}{Node}} \&node, \mbox{\hyperlink{classneo_1_1io_1_1_byte_span}{io\+::\+Byte\+Span}} path, \mbox{\hyperlink{classneo_1_1io_1_1_byte_vector}{io\+::\+Byte\+Vector}} \&value) const
\begin{DoxyCompactList}\small\item\em Internal get implementation. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{classneo_1_1cryptography_1_1mpttrie_1_1_trie_a4a5ba7a371a1ed15186f5c1bf5972fb9}{Put\+Internal}} (std\+::unique\+\_\+ptr$<$ \mbox{\hyperlink{classneo_1_1cryptography_1_1mpttrie_1_1_node}{Node}} $>$ \&node, \mbox{\hyperlink{classneo_1_1io_1_1_byte_span}{io\+::\+Byte\+Span}} path, std\+::unique\+\_\+ptr$<$ \mbox{\hyperlink{classneo_1_1cryptography_1_1mpttrie_1_1_node}{Node}} $>$ value\+\_\+node)
\begin{DoxyCompactList}\small\item\em Internal put implementation. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{classneo_1_1cryptography_1_1mpttrie_1_1_trie_a04c40e3b1862607a8fdb6d58532b9419}{Put\+Branch}} (std\+::unique\+\_\+ptr$<$ \mbox{\hyperlink{classneo_1_1cryptography_1_1mpttrie_1_1_node}{Node}} $>$ \&node, \mbox{\hyperlink{classneo_1_1io_1_1_byte_span}{io\+::\+Byte\+Span}} path, std\+::unique\+\_\+ptr$<$ \mbox{\hyperlink{classneo_1_1cryptography_1_1mpttrie_1_1_node}{Node}} $>$ value\+\_\+node)
\begin{DoxyCompactList}\small\item\em Put implementation for branch nodes. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{classneo_1_1cryptography_1_1mpttrie_1_1_trie_ae6f67ac3aae322da4d2f29ffec0ee55a}{Put\+Extension}} (std\+::unique\+\_\+ptr$<$ \mbox{\hyperlink{classneo_1_1cryptography_1_1mpttrie_1_1_node}{Node}} $>$ \&node, \mbox{\hyperlink{classneo_1_1io_1_1_byte_span}{io\+::\+Byte\+Span}} path, std\+::unique\+\_\+ptr$<$ \mbox{\hyperlink{classneo_1_1cryptography_1_1mpttrie_1_1_node}{Node}} $>$ value\+\_\+node)
\begin{DoxyCompactList}\small\item\em Put implementation for extension nodes. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{classneo_1_1cryptography_1_1mpttrie_1_1_trie_a296880b1766d030867417e27ce4a8d3e}{Put\+Leaf}} (std\+::unique\+\_\+ptr$<$ \mbox{\hyperlink{classneo_1_1cryptography_1_1mpttrie_1_1_node}{Node}} $>$ \&node, \mbox{\hyperlink{classneo_1_1io_1_1_byte_span}{io\+::\+Byte\+Span}} path, std\+::unique\+\_\+ptr$<$ \mbox{\hyperlink{classneo_1_1cryptography_1_1mpttrie_1_1_node}{Node}} $>$ value\+\_\+node)
\begin{DoxyCompactList}\small\item\em Put implementation for leaf nodes. \end{DoxyCompactList}\item 
bool \mbox{\hyperlink{classneo_1_1cryptography_1_1mpttrie_1_1_trie_a20c02a396981a32ff1561bdc39fc9c5c}{Try\+Delete\+Internal}} (std\+::unique\+\_\+ptr$<$ \mbox{\hyperlink{classneo_1_1cryptography_1_1mpttrie_1_1_node}{Node}} $>$ \&node, \mbox{\hyperlink{classneo_1_1io_1_1_byte_span}{io\+::\+Byte\+Span}} path)
\begin{DoxyCompactList}\small\item\em Internal delete implementation. \end{DoxyCompactList}\item 
bool \mbox{\hyperlink{classneo_1_1cryptography_1_1mpttrie_1_1_trie_ab87702b1925cd7854a7ffeb529322360}{Delete\+Branch}} (std\+::unique\+\_\+ptr$<$ \mbox{\hyperlink{classneo_1_1cryptography_1_1mpttrie_1_1_node}{Node}} $>$ \&node, \mbox{\hyperlink{classneo_1_1io_1_1_byte_span}{io\+::\+Byte\+Span}} path)
\begin{DoxyCompactList}\small\item\em Delete implementation for branch nodes. \end{DoxyCompactList}\item 
bool \mbox{\hyperlink{classneo_1_1cryptography_1_1mpttrie_1_1_trie_ad2531d29eaa1c3115dfd4c51b67584eb}{Delete\+Extension}} (std\+::unique\+\_\+ptr$<$ \mbox{\hyperlink{classneo_1_1cryptography_1_1mpttrie_1_1_node}{Node}} $>$ \&node, \mbox{\hyperlink{classneo_1_1io_1_1_byte_span}{io\+::\+Byte\+Span}} path)
\begin{DoxyCompactList}\small\item\em Delete implementation for extension nodes. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{classneo_1_1cryptography_1_1mpttrie_1_1_trie_a48cece275f8219e10ba9537abb7e0b5c}{Simplify\+Branch}} (std\+::unique\+\_\+ptr$<$ \mbox{\hyperlink{classneo_1_1cryptography_1_1mpttrie_1_1_node}{Node}} $>$ \&node)
\begin{DoxyCompactList}\small\item\em Simplifies a branch node if it has only one child. \end{DoxyCompactList}\item 
bool \mbox{\hyperlink{classneo_1_1cryptography_1_1mpttrie_1_1_trie_a502c8f6f05420da0dd9901ce098472fe}{Get\+Proof\+Internal}} (\mbox{\hyperlink{classneo_1_1cryptography_1_1mpttrie_1_1_node}{Node}} \&node, \mbox{\hyperlink{classneo_1_1io_1_1_byte_span}{io\+::\+Byte\+Span}} path, std\+::vector$<$ \mbox{\hyperlink{classneo_1_1io_1_1_byte_vector}{io\+::\+Byte\+Vector}} $>$ \&proof) const
\begin{DoxyCompactList}\small\item\em Internal proof generation implementation. \end{DoxyCompactList}\end{DoxyCompactItemize}
\doxysubsubsection*{Static Private Member Functions}
\begin{DoxyCompactItemize}
\item 
static std\+::vector$<$ uint8\+\_\+t $>$ \mbox{\hyperlink{classneo_1_1cryptography_1_1mpttrie_1_1_trie_ae6c57fcdbceddcf95162390652542bdd}{To\+Nibbles}} (\mbox{\hyperlink{classneo_1_1io_1_1_byte_span}{io\+::\+Byte\+Span}} key)
\begin{DoxyCompactList}\small\item\em Converts a key to nibbles (4-\/bit values). \end{DoxyCompactList}\item 
static \mbox{\hyperlink{classneo_1_1io_1_1_byte_vector}{io\+::\+Byte\+Vector}} \mbox{\hyperlink{classneo_1_1cryptography_1_1mpttrie_1_1_trie_a98b3b996fca23db5c5c7d47d076d398a}{Create\+Key}} (const \mbox{\hyperlink{classneo_1_1io_1_1_u_int256}{io\+::\+UInt256}} \&hash)
\begin{DoxyCompactList}\small\item\em Creates a storage key from hash. \end{DoxyCompactList}\item 
static size\+\_\+t \mbox{\hyperlink{classneo_1_1cryptography_1_1mpttrie_1_1_trie_aa5842d052a5310e9651e16a8b868eee5}{Common\+Prefix\+Length}} (\mbox{\hyperlink{classneo_1_1io_1_1_byte_span}{io\+::\+Byte\+Span}} a, \mbox{\hyperlink{classneo_1_1io_1_1_byte_span}{io\+::\+Byte\+Span}} b)
\begin{DoxyCompactList}\small\item\em Calculates the common prefix length between two byte spans. \end{DoxyCompactList}\end{DoxyCompactItemize}
\doxysubsubsection*{Private Attributes}
\begin{DoxyCompactItemize}
\item 
std\+::shared\+\_\+ptr$<$ \mbox{\hyperlink{classneo_1_1persistence_1_1_i_store_snapshot}{persistence\+::\+IStore\+Snapshot}} $>$ \mbox{\hyperlink{classneo_1_1cryptography_1_1mpttrie_1_1_trie_ae1a695b8ebeedcda3cc7e305773343c0}{store\+\_\+}}
\item 
std\+::unique\+\_\+ptr$<$ \mbox{\hyperlink{classneo_1_1cryptography_1_1mpttrie_1_1_cache}{Cache}} $>$ \mbox{\hyperlink{classneo_1_1cryptography_1_1mpttrie_1_1_trie_a4ec562f634e553bee506d5303be25fc9}{cache\+\_\+}}
\item 
std\+::unique\+\_\+ptr$<$ \mbox{\hyperlink{classneo_1_1cryptography_1_1mpttrie_1_1_node}{Node}} $>$ \mbox{\hyperlink{classneo_1_1cryptography_1_1mpttrie_1_1_trie_ad4754994576a939f638b88d433538f6e}{root\+\_\+}}
\item 
bool \mbox{\hyperlink{classneo_1_1cryptography_1_1mpttrie_1_1_trie_a28a0bbdabcbc5d78319b3746905bd04f}{full\+\_\+state\+\_\+}}
\end{DoxyCompactItemize}


\doxysubsection{Detailed Description}
Merkle Patricia \doxylink{classneo_1_1cryptography_1_1mpttrie_1_1_trie}{Trie} implementation. 

This class provides a production-\/ready implementation of the Merkle Patricia \doxylink{classneo_1_1cryptography_1_1mpttrie_1_1_trie}{Trie} data structure used in Neo blockchain for state storage. The MPT combines the efficiency of Patricia tries with the cryptographic integrity of Merkle trees.

Key features\+:
\begin{DoxyItemize}
\item Efficient key-\/value storage with cryptographic proofs
\item Reference counting to avoid duplicate node storage
\item \doxylink{classneo_1_1cryptography_1_1mpttrie_1_1_cache}{Cache} layer for optimal performance
\item Support for full or latest state modes
\item Merkle proof generation for light client verification 
\end{DoxyItemize}

\label{doc-constructors}
\Hypertarget{classneo_1_1cryptography_1_1mpttrie_1_1_trie_doc-constructors}
\doxysubsection{Constructor \& Destructor Documentation}
\Hypertarget{classneo_1_1cryptography_1_1mpttrie_1_1_trie_acb94e4c561edad5a0ae85e0b4a0ecaf8}\index{neo::cryptography::mpttrie::Trie@{neo::cryptography::mpttrie::Trie}!Trie@{Trie}}
\index{Trie@{Trie}!neo::cryptography::mpttrie::Trie@{neo::cryptography::mpttrie::Trie}}
\doxysubsubsection{\texorpdfstring{Trie()}{Trie()}}
{\footnotesize\ttfamily \label{classneo_1_1cryptography_1_1mpttrie_1_1_trie_acb94e4c561edad5a0ae85e0b4a0ecaf8} 
neo\+::cryptography\+::mpttrie\+::\+Trie\+::\+Trie (\begin{DoxyParamCaption}\item[{std\+::shared\+\_\+ptr$<$ \mbox{\hyperlink{classneo_1_1persistence_1_1_i_store_snapshot}{persistence\+::\+IStore\+Snapshot}} $>$}]{store}{, }\item[{\mbox{\hyperlink{classneo_1_1io_1_1_u_int256}{io\+::\+UInt256}}}]{root}{, }\item[{bool}]{full\+\_\+state}{ = {\ttfamily false}}\end{DoxyParamCaption})}



Constructs a \doxylink{classneo_1_1cryptography_1_1mpttrie_1_1_trie}{Trie} with the given store and root. 


\begin{DoxyParams}{Parameters}
{\em store} & The store snapshot for persistence. \\
\hline
{\em root} & The root hash of the trie. \\
\hline
{\em full\+\_\+state} & If true, keeps all historical state. If false, only latest state. \\
\hline
\end{DoxyParams}
Here is the call graph for this function\+:
% FIG 0


\label{doc-func-members}
\Hypertarget{classneo_1_1cryptography_1_1mpttrie_1_1_trie_doc-func-members}
\doxysubsection{Member Function Documentation}
\Hypertarget{classneo_1_1cryptography_1_1mpttrie_1_1_trie_a1f8e5fd88871945bbb5753cf901582f0}\index{neo::cryptography::mpttrie::Trie@{neo::cryptography::mpttrie::Trie}!Commit@{Commit}}
\index{Commit@{Commit}!neo::cryptography::mpttrie::Trie@{neo::cryptography::mpttrie::Trie}}
\doxysubsubsection{\texorpdfstring{Commit()}{Commit()}}
{\footnotesize\ttfamily \label{classneo_1_1cryptography_1_1mpttrie_1_1_trie_a1f8e5fd88871945bbb5753cf901582f0} 
void neo\+::cryptography\+::mpttrie\+::\+Trie\+::\+Commit (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption})}



Commits all pending changes to the store. 

\Hypertarget{classneo_1_1cryptography_1_1mpttrie_1_1_trie_aa5842d052a5310e9651e16a8b868eee5}\index{neo::cryptography::mpttrie::Trie@{neo::cryptography::mpttrie::Trie}!CommonPrefixLength@{CommonPrefixLength}}
\index{CommonPrefixLength@{CommonPrefixLength}!neo::cryptography::mpttrie::Trie@{neo::cryptography::mpttrie::Trie}}
\doxysubsubsection{\texorpdfstring{CommonPrefixLength()}{CommonPrefixLength()}}
{\footnotesize\ttfamily \label{classneo_1_1cryptography_1_1mpttrie_1_1_trie_aa5842d052a5310e9651e16a8b868eee5} 
size\+\_\+t neo\+::cryptography\+::mpttrie\+::\+Trie\+::\+Common\+Prefix\+Length (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classneo_1_1io_1_1_byte_span}{io\+::\+Byte\+Span}}}]{a}{, }\item[{\mbox{\hyperlink{classneo_1_1io_1_1_byte_span}{io\+::\+Byte\+Span}}}]{b}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}, {\ttfamily [private]}}



Calculates the common prefix length between two byte spans. 


\begin{DoxyParams}{Parameters}
{\em a} & First byte span. \\
\hline
{\em b} & Second byte span. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Length of common prefix. 
\end{DoxyReturn}
Here is the call graph for this function\+:
% FIG 1
\Hypertarget{classneo_1_1cryptography_1_1mpttrie_1_1_trie_a98b3b996fca23db5c5c7d47d076d398a}\index{neo::cryptography::mpttrie::Trie@{neo::cryptography::mpttrie::Trie}!CreateKey@{CreateKey}}
\index{CreateKey@{CreateKey}!neo::cryptography::mpttrie::Trie@{neo::cryptography::mpttrie::Trie}}
\doxysubsubsection{\texorpdfstring{CreateKey()}{CreateKey()}}
{\footnotesize\ttfamily \label{classneo_1_1cryptography_1_1mpttrie_1_1_trie_a98b3b996fca23db5c5c7d47d076d398a} 
\mbox{\hyperlink{classneo_1_1io_1_1_byte_vector}{io\+::\+Byte\+Vector}} neo\+::cryptography\+::mpttrie\+::\+Trie\+::\+Create\+Key (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{classneo_1_1io_1_1_u_int256}{io\+::\+UInt256}} \&}]{hash}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}, {\ttfamily [private]}}



Creates a storage key from hash. 


\begin{DoxyParams}{Parameters}
{\em hash} & The hash. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The storage key. 
\end{DoxyReturn}
\Hypertarget{classneo_1_1cryptography_1_1mpttrie_1_1_trie_a9df71d4f2796eb7272041c5e69fd3698}\index{neo::cryptography::mpttrie::Trie@{neo::cryptography::mpttrie::Trie}!Delete@{Delete}}
\index{Delete@{Delete}!neo::cryptography::mpttrie::Trie@{neo::cryptography::mpttrie::Trie}}
\doxysubsubsection{\texorpdfstring{Delete()}{Delete()}}
{\footnotesize\ttfamily \label{classneo_1_1cryptography_1_1mpttrie_1_1_trie_a9df71d4f2796eb7272041c5e69fd3698} 
bool neo\+::cryptography\+::mpttrie\+::\+Trie\+::\+Delete (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classneo_1_1io_1_1_byte_span}{io\+::\+Byte\+Span}}}]{key}{}\end{DoxyParamCaption})}



Deletes a key. 


\begin{DoxyParams}{Parameters}
{\em key} & The key. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
True if deleted, false if not found. 
\end{DoxyReturn}
Here is the call graph for this function\+:
% FIG 2
\Hypertarget{classneo_1_1cryptography_1_1mpttrie_1_1_trie_ab87702b1925cd7854a7ffeb529322360}\index{neo::cryptography::mpttrie::Trie@{neo::cryptography::mpttrie::Trie}!DeleteBranch@{DeleteBranch}}
\index{DeleteBranch@{DeleteBranch}!neo::cryptography::mpttrie::Trie@{neo::cryptography::mpttrie::Trie}}
\doxysubsubsection{\texorpdfstring{DeleteBranch()}{DeleteBranch()}}
{\footnotesize\ttfamily \label{classneo_1_1cryptography_1_1mpttrie_1_1_trie_ab87702b1925cd7854a7ffeb529322360} 
bool neo\+::cryptography\+::mpttrie\+::\+Trie\+::\+Delete\+Branch (\begin{DoxyParamCaption}\item[{std\+::unique\+\_\+ptr$<$ \mbox{\hyperlink{classneo_1_1cryptography_1_1mpttrie_1_1_node}{Node}} $>$ \&}]{node}{, }\item[{\mbox{\hyperlink{classneo_1_1io_1_1_byte_span}{io\+::\+Byte\+Span}}}]{path}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [private]}}



Delete implementation for branch nodes. 


\begin{DoxyParams}{Parameters}
{\em node} & The branch node. \\
\hline
{\em path} & The remaining path. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
True if deleted, false otherwise. 
\end{DoxyReturn}
Here is the call graph for this function\+:
% FIG 3
\Hypertarget{classneo_1_1cryptography_1_1mpttrie_1_1_trie_ad2531d29eaa1c3115dfd4c51b67584eb}\index{neo::cryptography::mpttrie::Trie@{neo::cryptography::mpttrie::Trie}!DeleteExtension@{DeleteExtension}}
\index{DeleteExtension@{DeleteExtension}!neo::cryptography::mpttrie::Trie@{neo::cryptography::mpttrie::Trie}}
\doxysubsubsection{\texorpdfstring{DeleteExtension()}{DeleteExtension()}}
{\footnotesize\ttfamily \label{classneo_1_1cryptography_1_1mpttrie_1_1_trie_ad2531d29eaa1c3115dfd4c51b67584eb} 
bool neo\+::cryptography\+::mpttrie\+::\+Trie\+::\+Delete\+Extension (\begin{DoxyParamCaption}\item[{std\+::unique\+\_\+ptr$<$ \mbox{\hyperlink{classneo_1_1cryptography_1_1mpttrie_1_1_node}{Node}} $>$ \&}]{node}{, }\item[{\mbox{\hyperlink{classneo_1_1io_1_1_byte_span}{io\+::\+Byte\+Span}}}]{path}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [private]}}



Delete implementation for extension nodes. 


\begin{DoxyParams}{Parameters}
{\em node} & The extension node. \\
\hline
{\em path} & The remaining path. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
True if deleted, false otherwise. 
\end{DoxyReturn}
Here is the call graph for this function\+:
% FIG 4
\Hypertarget{classneo_1_1cryptography_1_1mpttrie_1_1_trie_a4e13bf8260b5d25a1a4809b7257473d3}\index{neo::cryptography::mpttrie::Trie@{neo::cryptography::mpttrie::Trie}!Get@{Get}}
\index{Get@{Get}!neo::cryptography::mpttrie::Trie@{neo::cryptography::mpttrie::Trie}}
\doxysubsubsection{\texorpdfstring{Get()}{Get()}}
{\footnotesize\ttfamily \label{classneo_1_1cryptography_1_1mpttrie_1_1_trie_a4e13bf8260b5d25a1a4809b7257473d3} 
\mbox{\hyperlink{classneo_1_1io_1_1_byte_vector}{io\+::\+Byte\+Vector}} neo\+::cryptography\+::mpttrie\+::\+Trie\+::\+Get (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classneo_1_1io_1_1_byte_span}{io\+::\+Byte\+Span}}}]{key}{}\end{DoxyParamCaption}) const}



Gets a value by key. 


\begin{DoxyParams}{Parameters}
{\em key} & The key. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The value. 
\end{DoxyReturn}

\begin{DoxyExceptions}{Exceptions}
{\em std\+::out\+\_\+of\+\_\+range} & if key not found. \\
\hline
\end{DoxyExceptions}
Here is the call graph for this function\+:
% FIG 5
\Hypertarget{classneo_1_1cryptography_1_1mpttrie_1_1_trie_ab43f588d0c9b5c284b386b1261eb2327}\index{neo::cryptography::mpttrie::Trie@{neo::cryptography::mpttrie::Trie}!GetProof@{GetProof}}
\index{GetProof@{GetProof}!neo::cryptography::mpttrie::Trie@{neo::cryptography::mpttrie::Trie}}
\doxysubsubsection{\texorpdfstring{GetProof()}{GetProof()}}
{\footnotesize\ttfamily \label{classneo_1_1cryptography_1_1mpttrie_1_1_trie_ab43f588d0c9b5c284b386b1261eb2327} 
std\+::vector$<$ \mbox{\hyperlink{classneo_1_1io_1_1_byte_vector}{io\+::\+Byte\+Vector}} $>$ neo\+::cryptography\+::mpttrie\+::\+Trie\+::\+Get\+Proof (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classneo_1_1io_1_1_byte_span}{io\+::\+Byte\+Span}}}]{key}{}\end{DoxyParamCaption}) const}



Generates a Merkle proof for the given key. 


\begin{DoxyParams}{Parameters}
{\em key} & The key to generate proof for. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Vector of proof data (serialized nodes). 
\end{DoxyReturn}
Here is the call graph for this function\+:
% FIG 6
\Hypertarget{classneo_1_1cryptography_1_1mpttrie_1_1_trie_a502c8f6f05420da0dd9901ce098472fe}\index{neo::cryptography::mpttrie::Trie@{neo::cryptography::mpttrie::Trie}!GetProofInternal@{GetProofInternal}}
\index{GetProofInternal@{GetProofInternal}!neo::cryptography::mpttrie::Trie@{neo::cryptography::mpttrie::Trie}}
\doxysubsubsection{\texorpdfstring{GetProofInternal()}{GetProofInternal()}}
{\footnotesize\ttfamily \label{classneo_1_1cryptography_1_1mpttrie_1_1_trie_a502c8f6f05420da0dd9901ce098472fe} 
bool neo\+::cryptography\+::mpttrie\+::\+Trie\+::\+Get\+Proof\+Internal (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classneo_1_1cryptography_1_1mpttrie_1_1_node}{Node}} \&}]{node}{, }\item[{\mbox{\hyperlink{classneo_1_1io_1_1_byte_span}{io\+::\+Byte\+Span}}}]{path}{, }\item[{std\+::vector$<$ \mbox{\hyperlink{classneo_1_1io_1_1_byte_vector}{io\+::\+Byte\+Vector}} $>$ \&}]{proof}{}\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [private]}}



Internal proof generation implementation. 


\begin{DoxyParams}{Parameters}
{\em node} & The current node. \\
\hline
{\em path} & The remaining path. \\
\hline
{\em proof} & The proof accumulator. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
True if path exists, false otherwise. 
\end{DoxyReturn}
Here is the call graph for this function\+:
% FIG 7
\Hypertarget{classneo_1_1cryptography_1_1mpttrie_1_1_trie_ab25dc0911c19bfe1dedec52e6c41f0c5}\index{neo::cryptography::mpttrie::Trie@{neo::cryptography::mpttrie::Trie}!GetRootHash@{GetRootHash}}
\index{GetRootHash@{GetRootHash}!neo::cryptography::mpttrie::Trie@{neo::cryptography::mpttrie::Trie}}
\doxysubsubsection{\texorpdfstring{GetRootHash()}{GetRootHash()}}
{\footnotesize\ttfamily \label{classneo_1_1cryptography_1_1mpttrie_1_1_trie_ab25dc0911c19bfe1dedec52e6c41f0c5} 
\mbox{\hyperlink{classneo_1_1io_1_1_u_int256}{io\+::\+UInt256}} neo\+::cryptography\+::mpttrie\+::\+Trie\+::\+Get\+Root\+Hash (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption}) const}



Gets the root hash of the trie. 

\begin{DoxyReturn}{Returns}
The root hash. 
\end{DoxyReturn}
Here is the call graph for this function\+:
% FIG 8
\Hypertarget{classneo_1_1cryptography_1_1mpttrie_1_1_trie_a617016f6ce278a2b13ac57615c35bb89}\index{neo::cryptography::mpttrie::Trie@{neo::cryptography::mpttrie::Trie}!Put@{Put}}
\index{Put@{Put}!neo::cryptography::mpttrie::Trie@{neo::cryptography::mpttrie::Trie}}
\doxysubsubsection{\texorpdfstring{Put()}{Put()}}
{\footnotesize\ttfamily \label{classneo_1_1cryptography_1_1mpttrie_1_1_trie_a617016f6ce278a2b13ac57615c35bb89} 
void neo\+::cryptography\+::mpttrie\+::\+Trie\+::\+Put (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classneo_1_1io_1_1_byte_span}{io\+::\+Byte\+Span}}}]{key}{, }\item[{\mbox{\hyperlink{classneo_1_1io_1_1_byte_span}{io\+::\+Byte\+Span}}}]{value}{}\end{DoxyParamCaption})}



Puts a key-\/value pair. 


\begin{DoxyParams}{Parameters}
{\em key} & The key. \\
\hline
{\em value} & The value. \\
\hline
\end{DoxyParams}
Here is the call graph for this function\+:
% FIG 9
\Hypertarget{classneo_1_1cryptography_1_1mpttrie_1_1_trie_a04c40e3b1862607a8fdb6d58532b9419}\index{neo::cryptography::mpttrie::Trie@{neo::cryptography::mpttrie::Trie}!PutBranch@{PutBranch}}
\index{PutBranch@{PutBranch}!neo::cryptography::mpttrie::Trie@{neo::cryptography::mpttrie::Trie}}
\doxysubsubsection{\texorpdfstring{PutBranch()}{PutBranch()}}
{\footnotesize\ttfamily \label{classneo_1_1cryptography_1_1mpttrie_1_1_trie_a04c40e3b1862607a8fdb6d58532b9419} 
void neo\+::cryptography\+::mpttrie\+::\+Trie\+::\+Put\+Branch (\begin{DoxyParamCaption}\item[{std\+::unique\+\_\+ptr$<$ \mbox{\hyperlink{classneo_1_1cryptography_1_1mpttrie_1_1_node}{Node}} $>$ \&}]{node}{, }\item[{\mbox{\hyperlink{classneo_1_1io_1_1_byte_span}{io\+::\+Byte\+Span}}}]{path}{, }\item[{std\+::unique\+\_\+ptr$<$ \mbox{\hyperlink{classneo_1_1cryptography_1_1mpttrie_1_1_node}{Node}} $>$}]{value\+\_\+node}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [private]}}



Put implementation for branch nodes. 


\begin{DoxyParams}{Parameters}
{\em node} & The branch node. \\
\hline
{\em path} & The remaining path. \\
\hline
{\em value\+\_\+node} & The value node to insert. \\
\hline
\end{DoxyParams}
Here is the call graph for this function\+:
% FIG 10
\Hypertarget{classneo_1_1cryptography_1_1mpttrie_1_1_trie_ae6f67ac3aae322da4d2f29ffec0ee55a}\index{neo::cryptography::mpttrie::Trie@{neo::cryptography::mpttrie::Trie}!PutExtension@{PutExtension}}
\index{PutExtension@{PutExtension}!neo::cryptography::mpttrie::Trie@{neo::cryptography::mpttrie::Trie}}
\doxysubsubsection{\texorpdfstring{PutExtension()}{PutExtension()}}
{\footnotesize\ttfamily \label{classneo_1_1cryptography_1_1mpttrie_1_1_trie_ae6f67ac3aae322da4d2f29ffec0ee55a} 
void neo\+::cryptography\+::mpttrie\+::\+Trie\+::\+Put\+Extension (\begin{DoxyParamCaption}\item[{std\+::unique\+\_\+ptr$<$ \mbox{\hyperlink{classneo_1_1cryptography_1_1mpttrie_1_1_node}{Node}} $>$ \&}]{node}{, }\item[{\mbox{\hyperlink{classneo_1_1io_1_1_byte_span}{io\+::\+Byte\+Span}}}]{path}{, }\item[{std\+::unique\+\_\+ptr$<$ \mbox{\hyperlink{classneo_1_1cryptography_1_1mpttrie_1_1_node}{Node}} $>$}]{value\+\_\+node}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [private]}}



Put implementation for extension nodes. 


\begin{DoxyParams}{Parameters}
{\em node} & The extension node. \\
\hline
{\em path} & The remaining path. \\
\hline
{\em value\+\_\+node} & The value node to insert. \\
\hline
\end{DoxyParams}
Here is the call graph for this function\+:
% FIG 11
\Hypertarget{classneo_1_1cryptography_1_1mpttrie_1_1_trie_a4a5ba7a371a1ed15186f5c1bf5972fb9}\index{neo::cryptography::mpttrie::Trie@{neo::cryptography::mpttrie::Trie}!PutInternal@{PutInternal}}
\index{PutInternal@{PutInternal}!neo::cryptography::mpttrie::Trie@{neo::cryptography::mpttrie::Trie}}
\doxysubsubsection{\texorpdfstring{PutInternal()}{PutInternal()}}
{\footnotesize\ttfamily \label{classneo_1_1cryptography_1_1mpttrie_1_1_trie_a4a5ba7a371a1ed15186f5c1bf5972fb9} 
void neo\+::cryptography\+::mpttrie\+::\+Trie\+::\+Put\+Internal (\begin{DoxyParamCaption}\item[{std\+::unique\+\_\+ptr$<$ \mbox{\hyperlink{classneo_1_1cryptography_1_1mpttrie_1_1_node}{Node}} $>$ \&}]{node}{, }\item[{\mbox{\hyperlink{classneo_1_1io_1_1_byte_span}{io\+::\+Byte\+Span}}}]{path}{, }\item[{std\+::unique\+\_\+ptr$<$ \mbox{\hyperlink{classneo_1_1cryptography_1_1mpttrie_1_1_node}{Node}} $>$}]{value\+\_\+node}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [private]}}



Internal put implementation. 


\begin{DoxyParams}{Parameters}
{\em node} & The current node. \\
\hline
{\em path} & The remaining path. \\
\hline
{\em value\+\_\+node} & The node containing the value to insert. \\
\hline
\end{DoxyParams}
Here is the call graph for this function\+:
% FIG 12
\Hypertarget{classneo_1_1cryptography_1_1mpttrie_1_1_trie_a296880b1766d030867417e27ce4a8d3e}\index{neo::cryptography::mpttrie::Trie@{neo::cryptography::mpttrie::Trie}!PutLeaf@{PutLeaf}}
\index{PutLeaf@{PutLeaf}!neo::cryptography::mpttrie::Trie@{neo::cryptography::mpttrie::Trie}}
\doxysubsubsection{\texorpdfstring{PutLeaf()}{PutLeaf()}}
{\footnotesize\ttfamily \label{classneo_1_1cryptography_1_1mpttrie_1_1_trie_a296880b1766d030867417e27ce4a8d3e} 
void neo\+::cryptography\+::mpttrie\+::\+Trie\+::\+Put\+Leaf (\begin{DoxyParamCaption}\item[{std\+::unique\+\_\+ptr$<$ \mbox{\hyperlink{classneo_1_1cryptography_1_1mpttrie_1_1_node}{Node}} $>$ \&}]{node}{, }\item[{\mbox{\hyperlink{classneo_1_1io_1_1_byte_span}{io\+::\+Byte\+Span}}}]{path}{, }\item[{std\+::unique\+\_\+ptr$<$ \mbox{\hyperlink{classneo_1_1cryptography_1_1mpttrie_1_1_node}{Node}} $>$}]{value\+\_\+node}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [private]}}



Put implementation for leaf nodes. 


\begin{DoxyParams}{Parameters}
{\em node} & The leaf node. \\
\hline
{\em path} & The remaining path. \\
\hline
{\em value\+\_\+node} & The value node to insert. \\
\hline
\end{DoxyParams}
Here is the call graph for this function\+:
% FIG 13
\Hypertarget{classneo_1_1cryptography_1_1mpttrie_1_1_trie_a749d143c8e78332a2567ec3599f5f171}\index{neo::cryptography::mpttrie::Trie@{neo::cryptography::mpttrie::Trie}!SetRoot@{SetRoot}}
\index{SetRoot@{SetRoot}!neo::cryptography::mpttrie::Trie@{neo::cryptography::mpttrie::Trie}}
\doxysubsubsection{\texorpdfstring{SetRoot()}{SetRoot()}}
{\footnotesize\ttfamily \label{classneo_1_1cryptography_1_1mpttrie_1_1_trie_a749d143c8e78332a2567ec3599f5f171} 
void neo\+::cryptography\+::mpttrie\+::\+Trie\+::\+Set\+Root (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{classneo_1_1io_1_1_u_int256}{io\+::\+UInt256}} \&}]{root\+\_\+hash}{}\end{DoxyParamCaption})}



Sets the root hash of the trie. 


\begin{DoxyParams}{Parameters}
{\em root\+\_\+hash} & The new root hash. \\
\hline
\end{DoxyParams}
Here is the call graph for this function\+:
% FIG 14
\Hypertarget{classneo_1_1cryptography_1_1mpttrie_1_1_trie_a48cece275f8219e10ba9537abb7e0b5c}\index{neo::cryptography::mpttrie::Trie@{neo::cryptography::mpttrie::Trie}!SimplifyBranch@{SimplifyBranch}}
\index{SimplifyBranch@{SimplifyBranch}!neo::cryptography::mpttrie::Trie@{neo::cryptography::mpttrie::Trie}}
\doxysubsubsection{\texorpdfstring{SimplifyBranch()}{SimplifyBranch()}}
{\footnotesize\ttfamily \label{classneo_1_1cryptography_1_1mpttrie_1_1_trie_a48cece275f8219e10ba9537abb7e0b5c} 
void neo\+::cryptography\+::mpttrie\+::\+Trie\+::\+Simplify\+Branch (\begin{DoxyParamCaption}\item[{std\+::unique\+\_\+ptr$<$ \mbox{\hyperlink{classneo_1_1cryptography_1_1mpttrie_1_1_node}{Node}} $>$ \&}]{node}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [private]}}



Simplifies a branch node if it has only one child. 


\begin{DoxyParams}{Parameters}
{\em node} & The branch node to simplify. \\
\hline
\end{DoxyParams}
Here is the call graph for this function\+:
% FIG 15
\Hypertarget{classneo_1_1cryptography_1_1mpttrie_1_1_trie_ae6c57fcdbceddcf95162390652542bdd}\index{neo::cryptography::mpttrie::Trie@{neo::cryptography::mpttrie::Trie}!ToNibbles@{ToNibbles}}
\index{ToNibbles@{ToNibbles}!neo::cryptography::mpttrie::Trie@{neo::cryptography::mpttrie::Trie}}
\doxysubsubsection{\texorpdfstring{ToNibbles()}{ToNibbles()}}
{\footnotesize\ttfamily \label{classneo_1_1cryptography_1_1mpttrie_1_1_trie_ae6c57fcdbceddcf95162390652542bdd} 
std\+::vector$<$ uint8\+\_\+t $>$ neo\+::cryptography\+::mpttrie\+::\+Trie\+::\+To\+Nibbles (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classneo_1_1io_1_1_byte_span}{io\+::\+Byte\+Span}}}]{key}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}, {\ttfamily [private]}}



Converts a key to nibbles (4-\/bit values). 


\begin{DoxyParams}{Parameters}
{\em key} & The key. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The nibbles. 
\end{DoxyReturn}
\Hypertarget{classneo_1_1cryptography_1_1mpttrie_1_1_trie_a20c02a396981a32ff1561bdc39fc9c5c}\index{neo::cryptography::mpttrie::Trie@{neo::cryptography::mpttrie::Trie}!TryDeleteInternal@{TryDeleteInternal}}
\index{TryDeleteInternal@{TryDeleteInternal}!neo::cryptography::mpttrie::Trie@{neo::cryptography::mpttrie::Trie}}
\doxysubsubsection{\texorpdfstring{TryDeleteInternal()}{TryDeleteInternal()}}
{\footnotesize\ttfamily \label{classneo_1_1cryptography_1_1mpttrie_1_1_trie_a20c02a396981a32ff1561bdc39fc9c5c} 
bool neo\+::cryptography\+::mpttrie\+::\+Trie\+::\+Try\+Delete\+Internal (\begin{DoxyParamCaption}\item[{std\+::unique\+\_\+ptr$<$ \mbox{\hyperlink{classneo_1_1cryptography_1_1mpttrie_1_1_node}{Node}} $>$ \&}]{node}{, }\item[{\mbox{\hyperlink{classneo_1_1io_1_1_byte_span}{io\+::\+Byte\+Span}}}]{path}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [private]}}



Internal delete implementation. 


\begin{DoxyParams}{Parameters}
{\em node} & The current node. \\
\hline
{\em path} & The remaining path. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
True if deleted, false otherwise. 
\end{DoxyReturn}
Here is the call graph for this function\+:
% FIG 16
\Hypertarget{classneo_1_1cryptography_1_1mpttrie_1_1_trie_a8486a17f0dd0453858856db794889e62}\index{neo::cryptography::mpttrie::Trie@{neo::cryptography::mpttrie::Trie}!TryGet@{TryGet}}
\index{TryGet@{TryGet}!neo::cryptography::mpttrie::Trie@{neo::cryptography::mpttrie::Trie}}
\doxysubsubsection{\texorpdfstring{TryGet()}{TryGet()}}
{\footnotesize\ttfamily \label{classneo_1_1cryptography_1_1mpttrie_1_1_trie_a8486a17f0dd0453858856db794889e62} 
bool neo\+::cryptography\+::mpttrie\+::\+Trie\+::\+Try\+Get (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classneo_1_1io_1_1_byte_span}{io\+::\+Byte\+Span}}}]{key}{, }\item[{\mbox{\hyperlink{classneo_1_1io_1_1_byte_vector}{io\+::\+Byte\+Vector}} \&}]{value}{}\end{DoxyParamCaption}) const}



Tries to get a value by key. 


\begin{DoxyParams}{Parameters}
{\em key} & The key. \\
\hline
{\em value} & Output parameter for the value. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
True if found, false otherwise. 
\end{DoxyReturn}
Here is the call graph for this function\+:
% FIG 17
\Hypertarget{classneo_1_1cryptography_1_1mpttrie_1_1_trie_aa02584df98e54895ad67fb874b27fcc2}\index{neo::cryptography::mpttrie::Trie@{neo::cryptography::mpttrie::Trie}!TryGetInternal@{TryGetInternal}}
\index{TryGetInternal@{TryGetInternal}!neo::cryptography::mpttrie::Trie@{neo::cryptography::mpttrie::Trie}}
\doxysubsubsection{\texorpdfstring{TryGetInternal()}{TryGetInternal()}}
{\footnotesize\ttfamily \label{classneo_1_1cryptography_1_1mpttrie_1_1_trie_aa02584df98e54895ad67fb874b27fcc2} 
bool neo\+::cryptography\+::mpttrie\+::\+Trie\+::\+Try\+Get\+Internal (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classneo_1_1cryptography_1_1mpttrie_1_1_node}{Node}} \&}]{node}{, }\item[{\mbox{\hyperlink{classneo_1_1io_1_1_byte_span}{io\+::\+Byte\+Span}}}]{path}{, }\item[{\mbox{\hyperlink{classneo_1_1io_1_1_byte_vector}{io\+::\+Byte\+Vector}} \&}]{value}{}\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [private]}}



Internal get implementation. 


\begin{DoxyParams}{Parameters}
{\em node} & The current node. \\
\hline
{\em path} & The remaining path. \\
\hline
{\em value} & Output parameter for the value. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
True if found, false otherwise. 
\end{DoxyReturn}
Here is the call graph for this function\+:
% FIG 18


\label{doc-variable-members}
\Hypertarget{classneo_1_1cryptography_1_1mpttrie_1_1_trie_doc-variable-members}
\doxysubsection{Member Data Documentation}
\Hypertarget{classneo_1_1cryptography_1_1mpttrie_1_1_trie_a4ec562f634e553bee506d5303be25fc9}\index{neo::cryptography::mpttrie::Trie@{neo::cryptography::mpttrie::Trie}!cache\_@{cache\_}}
\index{cache\_@{cache\_}!neo::cryptography::mpttrie::Trie@{neo::cryptography::mpttrie::Trie}}
\doxysubsubsection{\texorpdfstring{cache\_}{cache\_}}
{\footnotesize\ttfamily \label{classneo_1_1cryptography_1_1mpttrie_1_1_trie_a4ec562f634e553bee506d5303be25fc9} 
std\+::unique\+\_\+ptr$<$\mbox{\hyperlink{classneo_1_1cryptography_1_1mpttrie_1_1_cache}{Cache}}$>$ neo\+::cryptography\+::mpttrie\+::\+Trie\+::cache\+\_\+\hspace{0.3cm}{\ttfamily [private]}}

\Hypertarget{classneo_1_1cryptography_1_1mpttrie_1_1_trie_a28a0bbdabcbc5d78319b3746905bd04f}\index{neo::cryptography::mpttrie::Trie@{neo::cryptography::mpttrie::Trie}!full\_state\_@{full\_state\_}}
\index{full\_state\_@{full\_state\_}!neo::cryptography::mpttrie::Trie@{neo::cryptography::mpttrie::Trie}}
\doxysubsubsection{\texorpdfstring{full\_state\_}{full\_state\_}}
{\footnotesize\ttfamily \label{classneo_1_1cryptography_1_1mpttrie_1_1_trie_a28a0bbdabcbc5d78319b3746905bd04f} 
bool neo\+::cryptography\+::mpttrie\+::\+Trie\+::full\+\_\+state\+\_\+\hspace{0.3cm}{\ttfamily [private]}}

\Hypertarget{classneo_1_1cryptography_1_1mpttrie_1_1_trie_ad4754994576a939f638b88d433538f6e}\index{neo::cryptography::mpttrie::Trie@{neo::cryptography::mpttrie::Trie}!root\_@{root\_}}
\index{root\_@{root\_}!neo::cryptography::mpttrie::Trie@{neo::cryptography::mpttrie::Trie}}
\doxysubsubsection{\texorpdfstring{root\_}{root\_}}
{\footnotesize\ttfamily \label{classneo_1_1cryptography_1_1mpttrie_1_1_trie_ad4754994576a939f638b88d433538f6e} 
std\+::unique\+\_\+ptr$<$\mbox{\hyperlink{classneo_1_1cryptography_1_1mpttrie_1_1_node}{Node}}$>$ neo\+::cryptography\+::mpttrie\+::\+Trie\+::root\+\_\+\hspace{0.3cm}{\ttfamily [private]}}

\Hypertarget{classneo_1_1cryptography_1_1mpttrie_1_1_trie_ae1a695b8ebeedcda3cc7e305773343c0}\index{neo::cryptography::mpttrie::Trie@{neo::cryptography::mpttrie::Trie}!store\_@{store\_}}
\index{store\_@{store\_}!neo::cryptography::mpttrie::Trie@{neo::cryptography::mpttrie::Trie}}
\doxysubsubsection{\texorpdfstring{store\_}{store\_}}
{\footnotesize\ttfamily \label{classneo_1_1cryptography_1_1mpttrie_1_1_trie_ae1a695b8ebeedcda3cc7e305773343c0} 
std\+::shared\+\_\+ptr$<$\mbox{\hyperlink{classneo_1_1persistence_1_1_i_store_snapshot}{persistence\+::\+IStore\+Snapshot}}$>$ neo\+::cryptography\+::mpttrie\+::\+Trie\+::store\+\_\+\hspace{0.3cm}{\ttfamily [private]}}



The documentation for this class was generated from the following files\+:\begin{DoxyCompactItemize}
\item 
include/neo/cryptography/mpttrie/\mbox{\hyperlink{trie_8h}{trie.\+h}}\item 
src/cryptography/mpttrie/\mbox{\hyperlink{trie_8cpp}{trie.\+cpp}}\end{DoxyCompactItemize}
