#!/usr/bin/env node
/**
 * GitHub Actions Workflow Check
 * Validates GitHub Actions workflow files
 * Auto-generated by AutoClaude
 */

const fs = require('fs');
const path = require('path');

// Try to load js-yaml, but continue without it if not available
let yaml;
try {
    yaml = require('js-yaml');
} catch (e) {
    // Will use fallback parser
}

// Simple YAML parser fallback if js-yaml is not available
function parseYAML(content) {
    try {
        if (yaml) {
            return yaml.load(content);
        }
        // Basic validation without full parsing
        const errors = [];
        const lines = content.split('\n');
        
        // Check for basic YAML syntax
        let indentLevel = 0;
        for (let i = 0; i < lines.length; i++) {
            const line = lines[i];
            const trimmed = line.trim();
            
            // Skip empty lines and comments
            if (!trimmed || trimmed.startsWith('#')) continue;
            
            // Check for tabs (YAML doesn't allow tabs)
            if (line.includes('\t')) {
                errors.push(`Line ${i + 1}: YAML files should not contain tabs`);
            }
            
            // Check for proper key-value format
            if (trimmed.includes(':') && !trimmed.match(/^[\w-]+:/)) {
                const beforeColon = trimmed.split(':')[0];
                if (beforeColon.includes(' ') && !beforeColon.startsWith('"') && !beforeColon.startsWith("'")) {
                    errors.push(`Line ${i + 1}: Keys with spaces must be quoted`);
                }
            }
        }
        
        if (errors.length > 0) {
            throw new Error(errors.join('; '));
        }
        
        return null; // Can't fully parse, but no obvious errors
    }
}

async function check() {
    const errors = [];
    const warnings = [];
    
    try {
        const workflowsDir = path.join(process.cwd(), '.github', 'workflows');
        
        if (!fs.existsSync(workflowsDir)) {
            warnings.push('No .github/workflows directory found');
            console.log(JSON.stringify({
                passed: true,
                errors: errors,
                warnings: warnings
            }, null, 2));
            return;
        }
        
        const files = fs.readdirSync(workflowsDir);
        const workflowFiles = files.filter(f => f.endsWith('.yml') || f.endsWith('.yaml'));
        
        if (workflowFiles.length === 0) {
            warnings.push('No workflow files found in .github/workflows');
        }
        
        for (const file of workflowFiles) {
            const filePath = path.join(workflowsDir, file);
            const content = fs.readFileSync(filePath, 'utf8');
            
            try {
                const workflow = parseYAML(content);
                
                if (workflow) {
                    // Validate workflow structure
                    if (!workflow.name) {
                        warnings.push(`${file}: Missing 'name' field`);
                    }
                    
                    if (!workflow.on) {
                        errors.push(`${file}: Missing 'on' trigger definition`);
                    }
                    
                    if (!workflow.jobs || Object.keys(workflow.jobs).length === 0) {
                        errors.push(`${file}: No jobs defined`);
                    }
                    
                    // Check for deprecated actions
                    const workflowString = JSON.stringify(workflow);
                    const deprecatedActions = [
                        { pattern: 'actions/setup-node@v1', replacement: 'actions/setup-node@v4' },
                        { pattern: 'actions/checkout@v1', replacement: 'actions/checkout@v4' },
                        { pattern: 'actions/checkout@v2', replacement: 'actions/checkout@v4' },
                        { pattern: 'actions/setup-python@v1', replacement: 'actions/setup-python@v4' },
                        { pattern: 'actions/cache@v1', replacement: 'actions/cache@v3' }
                    ];
                    
                    for (const { pattern, replacement } of deprecatedActions) {
                        if (workflowString.includes(pattern)) {
                            warnings.push(`${file}: Deprecated action '${pattern}' - use '${replacement}'`);
                        }
                    }
                    
                    // Check each job
                    if (workflow.jobs) {
                        for (const [jobName, job] of Object.entries(workflow.jobs)) {
                            if (!job['runs-on']) {
                                errors.push(`${file}: Job '${jobName}' missing 'runs-on'`);
                            }
                            
                            if (!job.steps || job.steps.length === 0) {
                                errors.push(`${file}: Job '${jobName}' has no steps`);
                            }
                            
                            // Check for hardcoded secrets
                            const jobString = JSON.stringify(job);
                            if (jobString.match(/['`"][A-Za-z0-9]{20,}['`"]/)) {
                                warnings.push(`${file}: Possible hardcoded secret in job '${jobName}'`);
                            }
                        }
                    }
                }
            } catch (parseError) {
                errors.push(`${file}: Invalid YAML - ${parseError.message}`);
            }
        }
        
    } catch (error) {
        errors.push(`GitHub Actions check failed: ${error.message}`);
    }
    
    // Output results
    console.log(JSON.stringify({
        passed: errors.length === 0,
        errors: errors,
        warnings: warnings
    }, null, 2));
}

// Run the check
check().then(result => {
    console.log(JSON.stringify(result, null, 2));
    process.exit(result.passed ? 0 : 1);
}).catch(error => {
    console.error(JSON.stringify({
        passed: false,
        errors: [`Unexpected error: ${error.message}`]
    }, null, 2));
    process.exit(1);
});