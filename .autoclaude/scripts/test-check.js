#!/usr/bin/env node
/**
 * Test Check Script
 * Verifies that all tests pass
 * Auto-generated by AutoClaude
 */

const { execSync } = require('child_process');
const fs = require('fs');
const path = require('path');

async function check() {
    const errors = [];
    const warnings = [];
    
    try {
        const projectRoot = process.cwd();
        let testsExecuted = false;
        
        // Check for Node.js project
        if (fs.existsSync(path.join(projectRoot, 'package.json'))) {
            const packageJson = JSON.parse(fs.readFileSync(path.join(projectRoot, 'package.json'), 'utf8'));
            
            // Check for test script
            if (packageJson.scripts && packageJson.scripts.test) {
                console.error('Running npm test...');
                try {
                    // Skip watch mode for CI
                    execSync('npm test -- --watchAll=false --ci', { encoding: 'utf8', stdio: 'pipe' });
                    testsExecuted = true;
                } catch (error) {
                    // Try without CI flags
                    try {
                        execSync('npm test', { encoding: 'utf8', stdio: 'pipe' });
                        testsExecuted = true;
                    } catch (error2) {
                        errors.push(`Tests failed: ${error2.message}`);
                        testsExecuted = true;
                    }
                }
            } else {
                warnings.push('No test script found in package.json');
            }
        }
        
        // Check for Go project
        if (!testsExecuted && (fs.existsSync(path.join(projectRoot, 'go.mod')) || 
                               fs.existsSync(path.join(projectRoot, 'main.go')))) {
            console.error('Running go test...');
            try {
                execSync('go test ./...', { encoding: 'utf8' });
                testsExecuted = true;
            } catch (error) {
                errors.push(`Go tests failed: ${error.message}`);
                testsExecuted = true;
            }
        }
        
        // Check for Rust project  
        if (!testsExecuted && fs.existsSync(path.join(projectRoot, 'Cargo.toml'))) {
            console.error('Running cargo test...');
            try {
                execSync('cargo test', { encoding: 'utf8' });
                testsExecuted = true;
            } catch (error) {
                errors.push(`Cargo tests failed: ${error.message}`);
                testsExecuted = true;
            }
        }
        
        // Check for .NET/C# project
        if (!testsExecuted && (fs.existsSync(path.join(projectRoot, '*.csproj')) || 
                               fs.existsSync(path.join(projectRoot, '*.sln')))) {
            console.error('Running dotnet test...');
            try {
                execSync('dotnet test', { encoding: 'utf8' });
                testsExecuted = true;
            } catch (error) {
                errors.push(`Dotnet tests failed: ${error.message}`);
                testsExecuted = true;
            }
        }
        
        // Check for Java project (Maven)
        if (!testsExecuted && fs.existsSync(path.join(projectRoot, 'pom.xml'))) {
            console.error('Running maven test...');
            try {
                execSync('mvn test', { encoding: 'utf8' });
                testsExecuted = true;
            } catch (error) {
                errors.push(`Maven tests failed: ${error.message}`);
                testsExecuted = true;
            }
        }
        
        // Check for Java project (Gradle)
        if (!testsExecuted && (fs.existsSync(path.join(projectRoot, 'build.gradle')) || 
                               fs.existsSync(path.join(projectRoot, 'build.gradle.kts')))) {
            console.error('Running gradle test...');
            try {
                execSync('./gradlew test', { encoding: 'utf8' });
                testsExecuted = true;
            } catch (error) {
                errors.push(`Gradle tests failed: ${error.message}`);
                testsExecuted = true;
            }
        }
        
        // Python - pytest/unittest
        if (!testsExecuted && (fs.existsSync(path.join(projectRoot, 'setup.py')) || 
                               fs.existsSync(path.join(projectRoot, 'pyproject.toml')) ||
                               fs.existsSync(path.join(projectRoot, 'requirements.txt')))) {
            const hasTests = fs.existsSync(path.join(projectRoot, 'tests')) || 
                           fs.existsSync(path.join(projectRoot, 'test'));
            
            if (hasTests) {
                // Try pytest first
                try {
                    console.error('Running pytest...');
                    execSync('pytest', { encoding: 'utf8' });
                    testsExecuted = true;
                } catch (error) {
                    // Try unittest
                    try {
                        console.error('Running python unittest...');
                        execSync('python -m unittest discover', { encoding: 'utf8' });
                        testsExecuted = true;
                    } catch (error2) {
                        errors.push(`Python tests failed: ${error2.message}`);
                        testsExecuted = true;
                    }
                }
            } else {
                warnings.push('Python project found but no test directory detected');
            }
        }
        
        // C++ with CMake/CTest
        if (!testsExecuted && fs.existsSync(path.join(projectRoot, 'CMakeLists.txt'))) {
            console.error('Checking for CMake/CTest configuration...');
            
            // Check if .test-runner config exists
            if (fs.existsSync(path.join(projectRoot, '.test-runner'))) {
                try {
                    const testConfig = JSON.parse(fs.readFileSync(path.join(projectRoot, '.test-runner'), 'utf8'));
                    if (testConfig.configured && testConfig.type === 'cmake-ctest') {
                        testsExecuted = true;
                        console.error('CMake/CTest test runner configured');
                    }
                } catch (e) {
                    warnings.push('Found .test-runner file but could not parse it');
                }
            }
            
            // Check if build directory exists with CTestTestfile.cmake
            else if (fs.existsSync(path.join(projectRoot, 'build', 'CTestTestfile.cmake'))) {
                testsExecuted = true;
                console.error('CTest configuration found in build directory');
            }
            
            // Check if run_tests.sh exists
            else if (fs.existsSync(path.join(projectRoot, 'run_tests.sh'))) {
                testsExecuted = true;
                console.error('Test runner script found: run_tests.sh');
            }
            
            if (!testsExecuted) {
                warnings.push('CMakeLists.txt found but no test runner configuration detected');
            }
        }
        
        // Ruby - RSpec/Minitest
        if (!testsExecuted && (fs.existsSync(path.join(projectRoot, 'Gemfile')) || 
                               fs.existsSync(path.join(projectRoot, '.ruby-version')))) {
            const hasSpec = fs.existsSync(path.join(projectRoot, 'spec'));
            const hasTest = fs.existsSync(path.join(projectRoot, 'test'));
            
            if (hasSpec) {
                try {
                    console.error('Running rspec...');
                    execSync('bundle exec rspec', { encoding: 'utf8' });
                    testsExecuted = true;
                } catch (error) {
                    errors.push(`RSpec tests failed: ${error.message}`);
                    testsExecuted = true;
                }
            } else if (hasTest) {
                try {
                    console.error('Running rake test...');
                    execSync('bundle exec rake test', { encoding: 'utf8' });
                    testsExecuted = true;
                } catch (error) {
                    warnings.push('Ruby test directory found but tests failed to run');
                }
            } else {
                warnings.push('Ruby project found but no test directory detected');
            }
        }
        
        if (!testsExecuted) {
            warnings.push('No recognized test framework found. Supported: npm test, jest, mocha, vitest, go test, cargo test, dotnet test, maven test, gradle test, pytest, unittest, rspec, rake test');
        }
        
        // Check for test files even if no runner was found
        if (!testsExecuted) {
            const testPatterns = ['*.test.js', '*.spec.js', '*.test.ts', '*.spec.ts', '*_test.go', '*_test.py', 'test_*.py', '*Test.java', '*Tests.cs'];
            let hasTestFiles = false;
            
            function findTestFiles(dir) {
                try {
                    const files = fs.readdirSync(dir);
                    for (const file of files) {
                        const filePath = path.join(dir, file);
                        const stat = fs.statSync(filePath);
                        
                        if (stat.isDirectory() && !file.startsWith('.') && file !== 'node_modules') {
                            findTestFiles(filePath);
                        } else if (stat.isFile()) {
                            for (const pattern of testPatterns) {
                                if (file.match(pattern.replace('*', '.*'))) {
                                    hasTestFiles = true;
                                    return;
                                }
                            }
                        }
                    }
                } catch (e) {
                    // Ignore permission errors
                }
            }
            
            findTestFiles(projectRoot);
            
            if (hasTestFiles) {
                errors.push('Test files found but no test runner detected or configured');
            }
        }
        
    } catch (error) {
        errors.push(`Test check failed: ${error.message}`);
    }
    
    // Output results
    console.log(JSON.stringify({
        passed: errors.length === 0,
        errors: errors,
        warnings: warnings
    }, null, 2));
}

// Run the check
check().catch(error => {
    console.error(`Unexpected error during test check: ${error.message}`);
    console.log(JSON.stringify({
        passed: false,
        errors: [`Unexpected error: ${error.message}`]
    }, null, 2));
    process.exit(1);
});