#!/usr/bin/env node
/**
 * Production Readiness Check
 * Checks for TODO, FIXME, placeholders, and incomplete implementations
 * Auto-generated by AutoClaude
 */

const fs = require('fs');
const path = require('path');

async function check() {
    const errors = [];
    const warnings = [];
    
    try {
        // Patterns that indicate incomplete or non-production code
        const patterns = [
            { pattern: /\/\/\s*TODO(?!\w)/gi, message: 'TODO comment found' },
            { pattern: /\/\/\s*FIXME(?!\w)/gi, message: 'FIXME comment found' },
            { pattern: /\/\/.*PLACEHOLDER/gi, message: 'Placeholder found' },
            { pattern: /\/\/\s*XXX(?!\w)/gi, message: 'XXX marker found' },
            { pattern: /\/\/\s*HACK(?!\w)/gi, message: 'HACK comment found' },
            { pattern: /\/\/.*\btemporary\b/gi, message: 'Temporary code found' },
            { pattern: /\/\/.*quick\s+fix/gi, message: 'Quick fix found' },
            { pattern: /\/\/.*for\s+now/gi, message: '"for now" comment found' },
            { pattern: /\/\/.*simplified/gi, message: 'Simplified implementation found' },
            { pattern: /\.\.\./, message: 'Ellipsis (...) found - possible incomplete code' },
            { pattern: /^[^\/]*<<<|>>>/, message: 'Merge conflict markers found' },
            { pattern: /\/\/.*not\s+implemented/gi, message: 'Not implemented found' },
            { pattern: /throw\s+.*Error\(['`"]not\s+implemented/gi, message: 'Not implemented error found' },
            { pattern: /console\.(log|debug|trace)/g, message: 'Debug console statement found' },
            { pattern: /debugger;/g, message: 'Debugger statement found' }
        ];
        
        // File extensions to check
        const extensions = ['.js', '.ts', '.jsx', '.tsx', '.go', '.cpp', '.cc', '.h', '.hpp', '.rs', '.cs', '.java', '.py', '.rb', '.php', '.swift', '.kt', '.scala', '.vue', '.svelte'];
        
        // Directories to skip
        const skipDirs = ['.git', 'node_modules', 'dist', 'build', 'out', 'target', 'bin', 'obj', '.next', '.nuxt', 'coverage', '.nyc_output', 'vendor', '.autoclaude', 'third_party', 'neo_csharp', 'scripts', 'tests'];
        
        // Files to skip (third-party libraries and non-production files)
        const skipFiles = [
            'include/neo/nlohmann/json.hpp',
            'include/nlohmann/json.hpp',
            'third_party/httplib/httplib.h',
            'apps/cli/main.cpp'  // CLI is not core production code
        ];
        
        function scanDirectory(dir) {
            const files = fs.readdirSync(dir);
            
            for (const file of files) {
                const filePath = path.join(dir, file);
                const stat = fs.statSync(filePath);
                
                if (stat.isDirectory()) {
                    if (!skipDirs.includes(file) && !file.startsWith('.')) {
                        scanDirectory(filePath);
                    }
                } else if (stat.isFile()) {
                    const ext = path.extname(file);
                    if (extensions.includes(ext)) {
                        checkFile(filePath, patterns);
                    }
                }
            }
        }
        
        function checkFile(filePath, patterns) {
            const content = fs.readFileSync(filePath, 'utf8');
            const lines = content.split('\n');
            const relativePath = path.relative(process.cwd(), filePath);
            const ext = path.extname(filePath);
            
            // Skip third-party files
            if (skipFiles.some(skipFile => relativePath.includes(skipFile))) {
                return;
            }
            
            patterns.forEach(({ pattern, message }) => {
                lines.forEach((line, index) => {
                    // Skip ellipsis in string literals (common in UI messages)
                    if (pattern.source === '\\.\\.\\.') {
                        // Check if ellipsis is within quotes or C++ variadic templates
                        const inString = /"[^"]*\.\.\.[^"]*"|'[^']*\.\.\.[^']*'/.test(line);
                        const isVariadicTemplate = /\w+\.\.\.\s*\w+|Args\.\.\.|\.\.\.args|typename\.\.\.|class\.\.\.|template\s*<.*\.\.\..*>|\(\s*\w+\&\&\.\.\.\s*\w+\s*\)/i.test(line);
                        if (inString || isVariadicTemplate) return;
                    }
                    
                    // Skip merge conflict patterns in template angle brackets
                    if (pattern.source === '<<<|>>>|===') {
                        const isTemplateAngles = /<[^<>]*>[^<>]*<[^<>]*>/.test(line) || 
                                                /std::(unordered_)?map<.*>/.test(line) ||
                                                /std::(unordered_)?set<.*>/.test(line) ||
                                                /std::vector<.*>/.test(line) ||
                                                /std::pair<.*>/.test(line) ||
                                                /std::function<.*>/.test(line) ||
                                                /<.*>::/.test(line) ||
                                                />>/.test(line);
                        if (isTemplateAngles) return;
                    }
                    
                    // Skip TODO/FIXME in method names like ToDouble()
                    if ((pattern.source === 'TODO' || pattern.source === 'FIXME') && pattern.flags === 'gi') {
                        const isMethodName = /\w*(TODO|FIXME)\w*\s*\(/.test(line) || 
                                           /ToDouble|ToDo/.test(line);
                        if (isMethodName) return;
                    }
                    
                    // Skip std::placeholders (common in C++ for function binding)
                    if (pattern.message === 'Placeholder found') {
                        const isStdPlaceholder = /std::placeholders::|placeholders::_\d+/.test(line);
                        if (isStdPlaceholder) return;
                    }
                    
                    if (pattern.test(line)) {
                        errors.push(`${relativePath}:${index + 1} - ${message}`);
                    }
                });
            });
            
            // Check for empty catch blocks
            const emptyCatchPattern = /catch\s*\([^)]*\)\s*{\s*}/g;
            if (emptyCatchPattern.test(content)) {
                warnings.push(`${relativePath} - Empty catch block found`);
            }
            
            // Check for any(...) type in TypeScript files
            if (ext === '.ts' || ext === '.tsx') {
                const anyTypePattern = /:\s*any\b/g;
                const anyMatches = content.match(anyTypePattern) || [];
                if (anyMatches.length > 0) {
                    warnings.push(`${relativePath} - Found ${anyMatches.length} uses of 'any' type`);
                }
            }
        }
        
        // Start scanning from current directory
        scanDirectory(process.cwd());
        
        // Additional checks
        if (errors.length === 0 && warnings.length === 0) {
            console.error('Production readiness check completed successfully');
        }
        
    } catch (error) {
        errors.push(`Production readiness check failed: ${error.message}`);
    }
    
    // Output results
    console.log(JSON.stringify({
        passed: errors.length === 0,
        errors: errors,
        warnings: warnings
    }, null, 2));
}

// Run the check
check().catch(error => {
    console.error(`Unexpected error during production readiness check: ${error.message}`);
    console.log(JSON.stringify({
        passed: false,
        errors: [`Unexpected error: ${error.message}`]
    }, null, 2));
    process.exit(1);
});