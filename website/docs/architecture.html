<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Architecture - Neo C++ Documentation</title>
    
    <link rel="icon" type="image/svg+xml" href="../assets/favicon.svg">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700;800&family=JetBrains+Mono:wght@400;500&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <link rel="stylesheet" href="../css/style.css">
    <link rel="stylesheet" href="../css/animations.css">
    <link rel="stylesheet" href="../css/responsive.css">
    <link rel="stylesheet" href="../css/docs.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css">
</head>
<body>
    <nav class="navbar" id="navbar">
        <div class="container">
            <div class="nav-wrapper">
                <a href="../index.html" class="logo">
                    <svg class="logo-icon" viewBox="0 0 40 40" width="40" height="40">
                        <path d="M20 5L35 15V25L20 35L5 25V15L20 5Z" fill="currentColor"/>
                    </svg>
                    <span class="logo-text">Neo C++</span>
                </a>
                
                <ul class="nav-menu">
                    <li><a href="../index.html" class="nav-link">Home</a></li>
                    <li><a href="getting-started.html" class="nav-link active">Docs</a></li>
                    <li><a href="api-reference.html" class="nav-link">API</a></li>
                    <li><a href="../examples/" class="nav-link">Examples</a></li>
                    <li><a href="https://github.com/r3e-network/neo_cpp" class="nav-link github-link">
                        <i class="fab fa-github"></i> GitHub
                    </a></li>
                </ul>
            </div>
        </div>
    </nav>

    <div class="docs-layout">
        <aside class="docs-sidebar">
            <div class="sidebar-section">
                <h4>Architecture</h4>
                <ul>
                    <li><a href="#overview" class="sidebar-link active">Overview</a></li>
                    <li><a href="#layers" class="sidebar-link">System Layers</a></li>
                    <li><a href="#components" class="sidebar-link">Core Components</a></li>
                    <li><a href="#flow" class="sidebar-link">Data Flow</a></li>
                    <li><a href="#design" class="sidebar-link">Design Patterns</a></li>
                </ul>
            </div>
            
            <div class="sidebar-section">
                <h4>Components</h4>
                <ul>
                    <li><a href="#blockchain" class="sidebar-link">Blockchain</a></li>
                    <li><a href="#consensus" class="sidebar-link">Consensus</a></li>
                    <li><a href="#networking" class="sidebar-link">Networking</a></li>
                    <li><a href="#vm" class="sidebar-link">Virtual Machine</a></li>
                    <li><a href="#storage" class="sidebar-link">Storage</a></li>
                </ul>
            </div>
            
            <div class="sidebar-section">
                <h4>Advanced</h4>
                <ul>
                    <li><a href="#plugins" class="sidebar-link">Plugin System</a></li>
                    <li><a href="#rpc" class="sidebar-link">RPC Architecture</a></li>
                    <li><a href="#security" class="sidebar-link">Security Model</a></li>
                    <li><a href="#performance" class="sidebar-link">Performance</a></li>
                </ul>
            </div>
        </aside>

        <main class="docs-content">
            <div class="docs-header">
                <h1>Neo C++ Architecture</h1>
                <p class="docs-description">
                    Deep dive into the system architecture and design of Neo C++
                </p>
            </div>

            <!-- Overview -->
            <section id="overview" class="docs-section">
                <h2>Architecture Overview</h2>
                <p>
                    Neo C++ is built with a modular, layered architecture that emphasizes performance, 
                    scalability, and maintainability. The implementation leverages modern C++20 features 
                    and follows SOLID principles throughout.
                </p>
                
                <div class="info-box">
                    <i class="fas fa-info-circle"></i>
                    <div>
                        <strong>Key Design Goals:</strong>
                        <ul>
                            <li>Zero-copy operations where possible</li>
                            <li>Lock-free data structures for high concurrency</li>
                            <li>Memory-mapped I/O for blockchain storage</li>
                            <li>Compile-time optimizations via templates</li>
                            <li>RAII for resource management</li>
                        </ul>
                    </div>
                </div>

                <h3>High-Level Architecture</h3>
                <pre><code class="language-plaintext">
┌─────────────────────────────────────────────────────────────┐
│                      Applications Layer                      │
│  ┌──────────┐  ┌──────────┐  ┌──────────┐  ┌──────────┐  │
│  │ Neo CLI  │  │ Neo Node │  │   SDK    │  │  Plugins │  │
│  └──────────┘  └──────────┘  └──────────┘  └──────────┘  │
├─────────────────────────────────────────────────────────────┤
│                        API Layer                             │
│  ┌──────────────────┐  ┌──────────────────────────────┐   │
│  │   RPC Server     │  │      WebSocket Server        │   │
│  └──────────────────┘  └──────────────────────────────┘   │
├─────────────────────────────────────────────────────────────┤
│                    Core Services Layer                       │
│  ┌──────────┐  ┌──────────┐  ┌──────────┐  ┌──────────┐  │
│  │Consensus │  │   P2P    │  │    VM    │  │  Wallet  │  │
│  └──────────┘  └──────────┘  └──────────┘  └──────────┘  │
├─────────────────────────────────────────────────────────────┤
│                   Blockchain Layer                           │
│  ┌──────────┐  ┌──────────┐  ┌──────────┐  ┌──────────┐  │
│  │  Ledger  │  │  Blocks  │  │    TX    │  │  Native  │  │
│  └──────────┘  └──────────┘  └──────────┘  └──────────┘  │
├─────────────────────────────────────────────────────────────┤
│                    Storage Layer                             │
│  ┌──────────┐  ┌──────────┐  ┌──────────┐  ┌──────────┐  │
│  │ RocksDB  │  │ LevelDB  │  │  Memory  │  │   Cache  │  │
│  └──────────┘  └──────────┘  └──────────┘  └──────────┘  │
└─────────────────────────────────────────────────────────────┘
</code></pre>
            </section>

            <!-- System Layers -->
            <section id="layers" class="docs-section">
                <h2>System Layers</h2>
                
                <h3>1. Storage Layer</h3>
                <p>The foundation layer providing persistent and in-memory storage capabilities.</p>
                <pre><code class="language-cpp">// Storage abstraction interface
class IStore {
public:
    virtual void Put(const Slice& key, const Slice& value) = 0;
    virtual std::optional<std::vector<uint8_t>> Get(const Slice& key) = 0;
    virtual void Delete(const Slice& key) = 0;
    virtual std::unique_ptr<IIterator> NewIterator() = 0;
};</code></pre>
                
                <h3>2. Blockchain Layer</h3>
                <p>Manages the blockchain state, block processing, and transaction validation.</p>
                <pre><code class="language-cpp">// Core blockchain management
namespace neo::ledger {
    class Blockchain {
        std::shared_ptr<IStore> store;
        std::shared_ptr<MemoryPool> mempool;
        std::atomic<uint32_t> height;
        
        bool AddBlock(const Block& block);
        bool VerifyBlock(const Block& block);
        void ProcessTransactions(const std::vector<Transaction>& txs);
    };
}</code></pre>

                <h3>3. Core Services Layer</h3>
                <p>Implements consensus, networking, VM execution, and wallet management.</p>
                
                <h3>4. API Layer</h3>
                <p>Provides RPC and WebSocket interfaces for external communication.</p>
                
                <h3>5. Applications Layer</h3>
                <p>User-facing applications including CLI, node software, and SDKs.</p>
            </section>

            <!-- Core Components -->
            <section id="components" class="docs-section">
                <h2>Core Components</h2>
                
                <h3 id="blockchain">Blockchain Component</h3>
                <p>Manages the distributed ledger and ensures data integrity.</p>
                
                <h4>Key Classes</h4>
                <ul>
                    <li><code>Blockchain</code> - Main blockchain management</li>
                    <li><code>Block</code> - Block structure and validation</li>
                    <li><code>Transaction</code> - Transaction processing</li>
                    <li><code>MemoryPool</code> - Pending transaction pool</li>
                    <li><code>HeaderCache</code> - Block header caching</li>
                </ul>

                <h4>Block Processing Flow</h4>
                <pre><code class="language-cpp">// Simplified block processing
bool Blockchain::AddBlock(const Block& block) {
    // 1. Verify block header
    if (!VerifyHeader(block.header)) return false;
    
    // 2. Verify transactions
    for (const auto& tx : block.transactions) {
        if (!VerifyTransaction(tx)) return false;
    }
    
    // 3. Execute transactions
    auto snapshot = store->GetSnapshot();
    for (const auto& tx : block.transactions) {
        ExecuteTransaction(snapshot, tx);
    }
    
    // 4. Update state
    snapshot->Commit();
    height.store(block.Index);
    
    // 5. Notify subscribers
    OnBlockAdded(block);
    return true;
}</code></pre>

                <h3 id="consensus">Consensus Component</h3>
                <p>Implements delegated Byzantine Fault Tolerance (dBFT) consensus mechanism.</p>
                
                <h4>Consensus States</h4>
                <pre><code class="language-cpp">enum class ConsensusState {
    Initial,
    Primary,
    Backup,
    RequestSent,
    RequestReceived,
    SignatureSent,
    BlockSent,
    ViewChanging
};</code></pre>

                <h4>Message Types</h4>
                <ul>
                    <li><code>PrepareRequest</code> - Primary node proposal</li>
                    <li><code>PrepareResponse</code> - Backup node response</li>
                    <li><code>ChangeView</code> - View change request</li>
                    <li><code>Commit</code> - Block commitment</li>
                    <li><code>RecoveryRequest</code> - Recovery initiation</li>
                    <li><code>RecoveryMessage</code> - Recovery data</li>
                </ul>

                <h3 id="networking">Networking Component</h3>
                <p>Handles peer-to-peer communication and message propagation.</p>
                
                <h4>Network Architecture</h4>
                <pre><code class="language-cpp">class P2PNetwork {
    std::vector<std::shared_ptr<Peer>> peers;
    std::shared_ptr<LocalNode> localNode;
    MessageHandler messageHandler;
    
    void BroadcastMessage(const Message& msg);
    void SendMessage(const Peer& peer, const Message& msg);
    void OnMessageReceived(const Peer& peer, const Message& msg);
};</code></pre>

                <h3 id="vm">Virtual Machine Component</h3>
                <p>Executes smart contracts with stack-based operations.</p>
                
                <h4>VM Architecture</h4>
                <pre><code class="language-cpp">class ExecutionEngine {
    EvaluationStack stack;
    Script script;
    ExecutionContext context;
    std::vector<InteropService> services;
    
    VMState Execute();
    void ExecuteOp(OpCode op);
    bool CheckWitness(const UInt160& hash);
};</code></pre>

                <h3 id="storage">Storage Component</h3>
                <p>Provides pluggable storage backends with caching.</p>
                
                <h4>Storage Hierarchy</h4>
                <ul>
                    <li><strong>L1 Cache</strong> - In-memory LRU cache (microsecond access)</li>
                    <li><strong>L2 Storage</strong> - RocksDB/LevelDB (millisecond access)</li>
                    <li><strong>L3 Archive</strong> - Cold storage for historical data</li>
                </ul>
            </section>

            <!-- Data Flow -->
            <section id="flow" class="docs-section">
                <h2>Data Flow</h2>
                
                <h3>Transaction Lifecycle</h3>
                <pre><code class="language-plaintext">
1. Transaction Creation
   └── User creates and signs transaction
   
2. Network Propagation
   ├── Transaction sent to peer nodes
   └── Validation by each node
   
3. Memory Pool
   ├── Valid transactions added to mempool
   └── Priority sorting by fee
   
4. Block Proposal
   ├── Primary node creates block proposal
   └── Includes transactions from mempool
   
5. Consensus
   ├── Backup nodes validate proposal
   ├── 2f+1 nodes must agree
   └── Block commitment
   
6. Block Persistence
   ├── Block written to storage
   ├── State updates applied
   └── Transaction receipts generated
   
7. Notification
   └── Subscribers notified of new block
</code></pre>

                <h3>Message Flow</h3>
                <p>P2P message propagation follows a gossip protocol with intelligent routing.</p>
                
                <pre><code class="language-cpp">// Message routing logic
void P2PNetwork::RouteMessage(const Message& msg) {
    // Check if already seen
    if (messageCache.Contains(msg.Hash())) return;
    
    // Validate message
    if (!ValidateMessage(msg)) return;
    
    // Process locally
    ProcessMessage(msg);
    
    // Propagate to peers
    for (auto& peer : GetConnectedPeers()) {
        if (!peer->KnowsMessage(msg.Hash())) {
            peer->SendMessage(msg);
        }
    }
    
    // Cache to prevent loops
    messageCache.Add(msg.Hash());
}</code></pre>
            </section>

            <!-- Design Patterns -->
            <section id="design" class="docs-section">
                <h2>Design Patterns</h2>
                
                <h3>Factory Pattern</h3>
                <p>Used for creating storage backends and network messages.</p>
                <pre><code class="language-cpp">class StorageFactory {
public:
    static std::unique_ptr<IStore> Create(const std::string& type) {
        if (type == "RocksDB") return std::make_unique<RocksDBStore>();
        if (type == "LevelDB") return std::make_unique<LevelDBStore>();
        if (type == "Memory") return std::make_unique<MemoryStore>();
        throw std::invalid_argument("Unknown storage type");
    }
};</code></pre>

                <h3>Observer Pattern</h3>
                <p>For blockchain event notifications.</p>
                <pre><code class="language-cpp">class BlockchainObserver {
public:
    virtual void OnBlockAdded(const Block& block) = 0;
    virtual void OnTransactionAdded(const Transaction& tx) = 0;
};

class Blockchain {
    std::vector<std::weak_ptr<BlockchainObserver>> observers;
    
    void NotifyBlockAdded(const Block& block) {
        for (auto& weak_obs : observers) {
            if (auto obs = weak_obs.lock()) {
                obs->OnBlockAdded(block);
            }
        }
    }
};</code></pre>

                <h3>Strategy Pattern</h3>
                <p>For consensus algorithms and validation rules.</p>
                <pre><code class="language-cpp">class IConsensusStrategy {
public:
    virtual bool ValidateBlock(const Block& block) = 0;
    virtual Block CreateBlock(const std::vector<Transaction>& txs) = 0;
};

class DBFTConsensus : public IConsensusStrategy {
    // dBFT specific implementation
};

class PoWConsensus : public IConsensusStrategy {
    // Proof of Work implementation (for testing)
};</code></pre>

                <h3>Command Pattern</h3>
                <p>For RPC command handling.</p>
                <pre><code class="language-cpp">class IRpcCommand {
public:
    virtual json Execute(const json& params) = 0;
};

class GetBlockCommand : public IRpcCommand {
    json Execute(const json& params) override {
        auto index = params["index"].get<uint32_t>();
        auto block = blockchain->GetBlock(index);
        return block.ToJson();
    }
};</code></pre>
            </section>

            <!-- Plugin System -->
            <section id="plugins" class="docs-section">
                <h2>Plugin System</h2>
                <p>Extensible plugin architecture for adding functionality.</p>
                
                <h3>Plugin Interface</h3>
                <pre><code class="language-cpp">class IPlugin {
public:
    virtual std::string GetName() const = 0;
    virtual std::string GetVersion() const = 0;
    virtual void OnEnable() = 0;
    virtual void OnDisable() = 0;
    virtual void OnBlockPersist(const Block& block) {}
    virtual void OnTransactionPersist(const Transaction& tx) {}
};</code></pre>

                <h3>Built-in Plugins</h3>
                <ul>
                    <li><strong>ApplicationLogs</strong> - Transaction execution logs</li>
                    <li><strong>StateService</strong> - State root calculation</li>
                    <li><strong>TokenTracker</strong> - NEP-17 token tracking</li>
                    <li><strong>OracleService</strong> - Oracle request handling</li>
                    <li><strong>DBFTPlugin</strong> - Consensus participation</li>
                </ul>
            </section>

            <!-- RPC Architecture -->
            <section id="rpc" class="docs-section">
                <h2>RPC Architecture</h2>
                
                <h3>JSON-RPC 2.0 Implementation</h3>
                <pre><code class="language-cpp">class RpcServer {
    std::map<std::string, std::unique_ptr<IRpcCommand>> commands;
    
    json ProcessRequest(const json& request) {
        auto method = request["method"].get<std::string>();
        auto params = request["params"];
        
        if (auto it = commands.find(method); it != commands.end()) {
            try {
                return it->second->Execute(params);
            } catch (const std::exception& e) {
                return MakeError(-32603, e.what());
            }
        }
        
        return MakeError(-32601, "Method not found");
    }
};</code></pre>

                <h3>Available RPC Methods</h3>
                <table class="docs-table">
                    <thead>
                        <tr>
                            <th>Method</th>
                            <th>Description</th>
                            <th>Parameters</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><code>getblockcount</code></td>
                            <td>Get current block height</td>
                            <td>None</td>
                        </tr>
                        <tr>
                            <td><code>getblock</code></td>
                            <td>Get block by index or hash</td>
                            <td>index/hash, verbose</td>
                        </tr>
                        <tr>
                            <td><code>gettransaction</code></td>
                            <td>Get transaction details</td>
                            <td>txid, verbose</td>
                        </tr>
                        <tr>
                            <td><code>sendrawtransaction</code></td>
                            <td>Broadcast transaction</td>
                            <td>hex</td>
                        </tr>
                        <tr>
                            <td><code>invokescript</code></td>
                            <td>Execute script</td>
                            <td>script, signers</td>
                        </tr>
                    </tbody>
                </table>
            </section>

            <!-- Security Model -->
            <section id="security" class="docs-section">
                <h2>Security Model</h2>
                
                <h3>Threat Mitigation</h3>
                <ul>
                    <li><strong>DDoS Protection</strong> - Rate limiting, connection throttling</li>
                    <li><strong>Eclipse Attacks</strong> - Peer diversity, anchor nodes</li>
                    <li><strong>Sybil Attacks</strong> - Proof of stake validation</li>
                    <li><strong>Double Spending</strong> - UTXO model, consensus validation</li>
                    <li><strong>Smart Contract Exploits</strong> - Gas limits, sandboxed execution</li>
                </ul>

                <h3>Cryptographic Security</h3>
                <pre><code class="language-cpp">// All cryptographic operations use validated libraries
namespace neo::crypto {
    // ECDSA with secp256r1
    bool VerifySignature(const UInt256& message, 
                         const ECPoint& publicKey,
                         const Signature& signature);
    
    // SHA256 for hashing
    UInt256 SHA256(const std::vector<uint8_t>& data);
    
    // AES-256 for encryption
    std::vector<uint8_t> AESEncrypt(const std::vector<uint8_t>& data,
                                    const std::vector<uint8_t>& key);
}</code></pre>
            </section>

            <!-- Performance -->
            <section id="performance" class="docs-section">
                <h2>Performance Optimizations</h2>
                
                <h3>Memory Management</h3>
                <ul>
                    <li><strong>Object Pooling</strong> - Reuse frequently allocated objects</li>
                    <li><strong>Memory Mapping</strong> - Direct file access for large datasets</li>
                    <li><strong>Arena Allocation</strong> - Bulk allocation for transactions</li>
                    <li><strong>Smart Pointers</strong> - Automatic memory management</li>
                </ul>

                <h3>Concurrency</h3>
                <pre><code class="language-cpp">// Lock-free data structures
template<typename T>
class LockFreeQueue {
    std::atomic<Node*> head;
    std::atomic<Node*> tail;
public:
    void enqueue(T item);
    std::optional<T> dequeue();
};

// Thread pool for parallel processing
class ThreadPool {
    std::vector<std::thread> workers;
    LockFreeQueue<std::function<void()>> tasks;
    
    template<typename F>
    auto submit(F&& f) -> std::future<decltype(f())>;
};</code></pre>

                <h3>Benchmarks</h3>
                <table class="docs-table">
                    <thead>
                        <tr>
                            <th>Operation</th>
                            <th>Performance</th>
                            <th>Notes</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td>Block Processing</td>
                            <td>&lt;100ms</td>
                            <td>Average for 500 TX block</td>
                        </tr>
                        <tr>
                            <td>Transaction Validation</td>
                            <td>&lt;1ms</td>
                            <td>Single transaction</td>
                        </tr>
                        <tr>
                            <td>VM Execution</td>
                            <td>1M ops/sec</td>
                            <td>Simple operations</td>
                        </tr>
                        <tr>
                            <td>RPC Response</td>
                            <td>&lt;10ms</td>
                            <td>Average latency</td>
                        </tr>
                        <tr>
                            <td>P2P Message</td>
                            <td>&lt;50ms</td>
                            <td>Network propagation</td>
                        </tr>
                    </tbody>
                </table>

                <div class="success-box">
                    <i class="fas fa-rocket"></i>
                    <div>
                        <strong>Performance Achievement:</strong>
                        Neo C++ achieves 10,000+ TPS in benchmark conditions with proper hardware and network configuration.
                    </div>
                </div>
            </section>

            <!-- Next Steps -->
            <section class="docs-section">
                <h2>Next Steps</h2>
                
                <div class="next-steps-grid">
                    <a href="consensus.html" class="next-step-card">
                        <i class="fas fa-handshake"></i>
                        <h3>Consensus Details</h3>
                        <p>Deep dive into dBFT consensus</p>
                    </a>
                    
                    <a href="vm.html" class="next-step-card">
                        <i class="fas fa-microchip"></i>
                        <h3>Virtual Machine</h3>
                        <p>Smart contract execution engine</p>
                    </a>
                    
                    <a href="networking.html" class="next-step-card">
                        <i class="fas fa-network-wired"></i>
                        <h3>P2P Networking</h3>
                        <p>Network protocol and messaging</p>
                    </a>
                </div>
            </section>
        </main>
    </div>

    <footer class="footer">
        <div class="container">
            <div class="footer-content">
                <p>&copy; 2024 Neo C++ Project. Released under the MIT License.</p>
                <div class="footer-links">
                    <a href="https://github.com/r3e-network/neo_cpp">GitHub</a>
                    <a href="https://discord.gg/neo">Discord</a>
                    <a href="https://neo.org">Neo.org</a>
                </div>
            </div>
        </div>
    </footer>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-cpp.min.js"></script>
    <script src="../js/main.js"></script>
    <script src="../js/docs.js"></script>
</body>
</html>