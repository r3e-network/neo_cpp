#include "neo/io/caching/fifo_cache.h"
#include "neo/io/caching/relay_cache.h"
#include "neo/io/uint256.h"
#include "neo/ledger/signer.h"
#include "neo/ledger/transaction_attribute.h"
#include "neo/ledger/witness.h"
#include "neo/network/p2p/payloads/inventory.h"
#include "neo/network/p2p/payloads/transaction.h"
#include <gmock/gmock.h>
#include <gtest/gtest.h>

using namespace neo::io::caching;
using namespace neo::network::p2p::payloads;
using namespace neo::io;
using namespace neo::ledger;

// Mock inventory implementation for testing
class MockInventory : public IInventory
{
  public:
    MockInventory(UInt256 hash, InventoryType type) : hash_(hash), type_(type) {}

    UInt256 GetHash() const override
    {
        return hash_;
    }
    InventoryType GetInventoryType() const override
    {
        return type_;
    }

    void Serialize(BinaryWriter& writer) const override
    {
        writer.WriteBytes(hash_.GetBytes());
    }

    void Deserialize(BinaryReader& reader) override
    {
        auto bytes = reader.ReadBytes(32);
        hash_ = UInt256(bytes);
    }

    size_t GetSize() const override
    {
        return 32;
    }

  private:
    UInt256 hash_;
    InventoryType type_;
};

// Test transaction implementation
class TestTransaction : public Transaction
{
  public:
    TestTransaction() : Transaction()
    {
        // Initialize with test values
        version_ = 1;
        nonce_ = 12345;
        system_fee_ = 1000000;
        network_fee_ = 500000;
        valid_until_block_ = 2000000;

        // Add some test script
        script_ = {0x41, 0x9e, 0xd0, 0xdc};  // Some opcodes

        // Create test signer
        auto signer = std::make_shared<Signer>();
        signer->SetAccount(UInt160::Zero());
        signer->SetScopes(WitnessScope::CalledByEntry);
        signers_.push_back(signer);

        // Create test witness
        auto witness = std::make_shared<Witness>(std::vector<uint8_t>{0x01, 0x02},  // invocation script
                                                 std::vector<uint8_t>{0x03, 0x04}   // verification script
        );
        witnesses_.push_back(witness);

        // Calculate hash
        CalculateHash();
    }

    // Override for testing
    UInt256 GetHash() const override
    {
        if (hash_.IsZero())
        {
            const_cast<TestTransaction*>(this)->CalculateHash();
        }
        return hash_;
    }

  private:
    void CalculateHash()
    {
        // Simple hash calculation for testing
        std::vector<uint8_t> data;
        data.insert(data.end(), reinterpret_cast<const uint8_t*>(&version_),
                    reinterpret_cast<const uint8_t*>(&version_) + sizeof(version_));
        data.insert(data.end(), reinterpret_cast<const uint8_t*>(&nonce_),
                    reinterpret_cast<const uint8_t*>(&nonce_) + sizeof(nonce_));

        // Use a simple hash function for testing
        uint256_t hash_value = 0;
        for (size_t i = 0; i < data.size(); ++i)
        {
            hash_value = hash_value * 31 + data[i];
        }

        std::vector<uint8_t> hash_bytes(32, 0);
        std::memcpy(hash_bytes.data(), &hash_value, std::min(sizeof(hash_value), hash_bytes.size()));
        hash_ = UInt256(hash_bytes);
    }

    mutable UInt256 hash_;
};

class RelayCacheTest : public ::testing::Test
{
  protected:
    void SetUp() override
    {
        // Initialize relay cache with capacity of 10 (same as C# test)
        relay_cache_ = std::make_unique<RelayCache>(10);
    }

    std::unique_ptr<RelayCache> relay_cache_;
};

TEST_F(RelayCacheTest, GetKeyForItem)
{
    // Create a test transaction (equivalent to C# test)
    auto transaction = std::make_shared<TestTransaction>();

    // Add transaction to cache
    relay_cache_->Add(transaction);

    // Verify cache contains the transaction
    EXPECT_EQ(relay_cache_->GetCount(), 1);
    EXPECT_TRUE(relay_cache_->Contains(transaction->GetHash()));

    // Test key-based retrieval
    std::shared_ptr<IInventory> retrieved_item;
    EXPECT_TRUE(relay_cache_->TryGet(transaction->GetHash(), retrieved_item));
    ASSERT_NE(retrieved_item, nullptr);

    // Verify retrieved item is actually a Transaction
    auto retrieved_transaction = std::dynamic_pointer_cast<Transaction>(retrieved_item);
    ASSERT_NE(retrieved_transaction, nullptr);
    EXPECT_EQ(retrieved_transaction->GetHash(), transaction->GetHash());
}

TEST_F(RelayCacheTest, FIFOBehavior)
{
    // Fill cache to capacity
    std::vector<std::shared_ptr<TestTransaction>> transactions;
    for (int i = 0; i < 10; ++i)
    {
        auto tx = std::make_shared<TestTransaction>();
        transactions.push_back(tx);
        relay_cache_->Add(tx);
    }

    EXPECT_EQ(relay_cache_->GetCount(), 10);

    // All transactions should be in cache
    for (const auto& tx : transactions)
    {
        EXPECT_TRUE(relay_cache_->Contains(tx->GetHash()));
    }

    // Add one more - should evict first item (FIFO)
    auto new_tx = std::make_shared<TestTransaction>();
    relay_cache_->Add(new_tx);

    EXPECT_EQ(relay_cache_->GetCount(), 10);
    EXPECT_FALSE(relay_cache_->Contains(transactions[0]->GetHash()));  // First item evicted
    EXPECT_TRUE(relay_cache_->Contains(new_tx->GetHash()));            // New item present

    // Other items should still be present
    for (size_t i = 1; i < transactions.size(); ++i)
    {
        EXPECT_TRUE(relay_cache_->Contains(transactions[i]->GetHash()));
    }
}

TEST_F(RelayCacheTest, DifferentInventoryTypes)
{
    // Test with different inventory types
    auto tx_hash = UInt256::Parse("0x1234567890123456789012345678901234567890123456789012345678901234");
    auto block_hash = UInt256::Parse("0x9876543210987654321098765432109876543210987654321098765432109876");

    auto transaction = std::make_shared<MockInventory>(tx_hash, InventoryType::TX);
    auto block = std::make_shared<MockInventory>(block_hash, InventoryType::Block);

    relay_cache_->Add(transaction);
    relay_cache_->Add(block);

    EXPECT_EQ(relay_cache_->GetCount(), 2);
    EXPECT_TRUE(relay_cache_->Contains(tx_hash));
    EXPECT_TRUE(relay_cache_->Contains(block_hash));

    // Retrieve and verify types
    std::shared_ptr<IInventory> retrieved_tx, retrieved_block;
    EXPECT_TRUE(relay_cache_->TryGet(tx_hash, retrieved_tx));
    EXPECT_TRUE(relay_cache_->TryGet(block_hash, retrieved_block));

    EXPECT_EQ(retrieved_tx->GetInventoryType(), InventoryType::TX);
    EXPECT_EQ(retrieved_block->GetInventoryType(), InventoryType::Block);
}

TEST_F(RelayCacheTest, DuplicateHashes)
{
    auto hash = UInt256::Parse("0x1111111111111111111111111111111111111111111111111111111111111111");

    auto item1 = std::make_shared<MockInventory>(hash, InventoryType::TX);
    auto item2 = std::make_shared<MockInventory>(hash, InventoryType::TX);

    relay_cache_->Add(item1);
    relay_cache_->Add(item2);

    // Should only have one item (duplicate hash)
    EXPECT_EQ(relay_cache_->GetCount(), 1);
    EXPECT_TRUE(relay_cache_->Contains(hash));
}

TEST_F(RelayCacheTest, EmptyCache)
{
    EXPECT_EQ(relay_cache_->GetCount(), 0);

    auto hash = UInt256::Parse("0x1234567890123456789012345678901234567890123456789012345678901234");
    EXPECT_FALSE(relay_cache_->Contains(hash));

    std::shared_ptr<IInventory> item;
    EXPECT_FALSE(relay_cache_->TryGet(hash, item));
    EXPECT_EQ(item, nullptr);
}

TEST_F(RelayCacheTest, ClearCache)
{
    // Add some items
    for (int i = 0; i < 5; ++i)
    {
        auto tx = std::make_shared<TestTransaction>();
        relay_cache_->Add(tx);
    }

    EXPECT_EQ(relay_cache_->GetCount(), 5);

    relay_cache_->Clear();
    EXPECT_EQ(relay_cache_->GetCount(), 0);
}

TEST_F(RelayCacheTest, ZeroCapacity)
{
    auto zero_cache = std::make_unique<RelayCache>(0);

    auto tx = std::make_shared<TestTransaction>();
    zero_cache->Add(tx);

    EXPECT_EQ(zero_cache->GetCount(), 0);
    EXPECT_FALSE(zero_cache->Contains(tx->GetHash()));
}

TEST_F(RelayCacheTest, SingleItemCapacity)
{
    auto single_cache = std::make_unique<RelayCache>(1);

    auto tx1 = std::make_shared<TestTransaction>();
    auto tx2 = std::make_shared<TestTransaction>();

    single_cache->Add(tx1);
    EXPECT_EQ(single_cache->GetCount(), 1);
    EXPECT_TRUE(single_cache->Contains(tx1->GetHash()));

    single_cache->Add(tx2);
    EXPECT_EQ(single_cache->GetCount(), 1);
    EXPECT_FALSE(single_cache->Contains(tx1->GetHash()));  // Evicted
    EXPECT_TRUE(single_cache->Contains(tx2->GetHash()));
}

TEST_F(RelayCacheTest, LargeCapacity)
{
    auto large_cache = std::make_unique<RelayCache>(1000);

    std::vector<std::shared_ptr<TestTransaction>> transactions;
    for (int i = 0; i < 500; ++i)
    {
        auto tx = std::make_shared<TestTransaction>();
        transactions.push_back(tx);
        large_cache->Add(tx);
    }

    EXPECT_EQ(large_cache->GetCount(), 500);

    // All items should still be present
    for (const auto& tx : transactions)
    {
        EXPECT_TRUE(large_cache->Contains(tx->GetHash()));
    }
}

TEST_F(RelayCacheTest, HashCollisionHandling)
{
    // Test behavior when different items have same hash (edge case)
    auto hash = UInt256::Parse("0x2222222222222222222222222222222222222222222222222222222222222222");

    auto item1 = std::make_shared<MockInventory>(hash, InventoryType::TX);
    auto item2 = std::make_shared<MockInventory>(hash, InventoryType::Block);

    relay_cache_->Add(item1);
    relay_cache_->Add(item2);

    // Cache should handle this gracefully (either replace or ignore duplicate)
    EXPECT_EQ(relay_cache_->GetCount(), 1);
    EXPECT_TRUE(relay_cache_->Contains(hash));

    std::shared_ptr<IInventory> retrieved;
    EXPECT_TRUE(relay_cache_->TryGet(hash, retrieved));
    ASSERT_NE(retrieved, nullptr);
}

TEST_F(RelayCacheTest, ThreadSafety)
{
    // Basic thread safety test
    std::vector<std::thread> threads;
    std::vector<std::shared_ptr<TestTransaction>> all_transactions;
    std::mutex transactions_mutex;

    for (int t = 0; t < 4; ++t)
    {
        threads.emplace_back(
            [this, t, &all_transactions, &transactions_mutex]()
            {
                for (int i = 0; i < 5; ++i)
                {
                    auto tx = std::make_shared<TestTransaction>();

                    {
                        std::lock_guard<std::mutex> lock(transactions_mutex);
                        all_transactions.push_back(tx);
                    }

                    relay_cache_->Add(tx);

                    // Try to retrieve it
                    std::shared_ptr<IInventory> retrieved;
                    relay_cache_->TryGet(tx->GetHash(), retrieved);
                }
            });
    }

    for (auto& thread : threads)
    {
        thread.join();
    }

    // Cache should maintain consistency
    EXPECT_LE(relay_cache_->GetCount(), 10);  // Should not exceed capacity
    EXPECT_GE(relay_cache_->GetCount(), 1);   // Should have at least one item
}

TEST_F(RelayCacheTest, MemoryManagement)
{
    // Test that items are properly managed when evicted
    std::weak_ptr<TestTransaction> weak_ref;

    {
        auto tx = std::make_shared<TestTransaction>();
        weak_ref = tx;
        relay_cache_->Add(tx);

        EXPECT_FALSE(weak_ref.expired());
    }

    // Item should still be alive in cache
    EXPECT_FALSE(weak_ref.expired());

    // Fill cache to trigger eviction
    for (int i = 0; i < 15; ++i)
    {
        auto new_tx = std::make_shared<TestTransaction>();
        relay_cache_->Add(new_tx);
    }

    // Original item should be evicted and destroyed
    EXPECT_TRUE(weak_ref.expired());
}

TEST_F(RelayCacheTest, IterationOrder)
{
    std::vector<std::shared_ptr<TestTransaction>> transactions;
    std::vector<UInt256> insertion_order;

    // Add items in specific order
    for (int i = 0; i < 5; ++i)
    {
        auto tx = std::make_shared<TestTransaction>();
        transactions.push_back(tx);
        insertion_order.push_back(tx->GetHash());
        relay_cache_->Add(tx);
    }

    // Verify all items are present
    for (const auto& hash : insertion_order)
    {
        EXPECT_TRUE(relay_cache_->Contains(hash));
    }

    // Add more items to trigger some evictions
    for (int i = 0; i < 8; ++i)
    {
        auto tx = std::make_shared<TestTransaction>();
        relay_cache_->Add(tx);
    }

    // First items should be evicted (FIFO behavior)
    EXPECT_FALSE(relay_cache_->Contains(insertion_order[0]));
    EXPECT_FALSE(relay_cache_->Contains(insertion_order[1]));
    EXPECT_FALSE(relay_cache_->Contains(insertion_order[2]));
    EXPECT_TRUE(relay_cache_->Contains(insertion_order[3]));
    EXPECT_TRUE(relay_cache_->Contains(insertion_order[4]));
}